-- HEADER --------------------------------------------------------------
-- ---------------------------------------------------------------------
--
--  Comments:  This file contains an implementation of the RFC 1213 MIB.
--
-- ---------------------------------------------------------------------
-- END -----------------------------------------------------------------

-- Definitions for RFC1213-MIB
mib-2                                   mgmt.1                                                                           
%% DisplayString OCTET
%% PhysAddress OCTET
system                                  mib-2.1                                                                          
interfaces                              mib-2.2                                                                          
-- at                                      mib-2.3                                                                          
ip                                      mib-2.4                                                                          
icmp                                    mib-2.5                                                                          
tcp                                     mib-2.6                                                                          
udp                                     mib-2.7                                                                          
-- egp                                     mib-2.8                                                                          
transmission                            mib-2.10                                                                         
snmp                                    mib-2.11                                                                         
sysDescr                                system.1                                DisplayString   read-only       mandatory   
sysObjectID                             system.2                                OBJECT          read-only       mandatory   
sysUpTime                               system.3                                TimeTicks       read-only       mandatory   
sysContact                              system.4                                DisplayString   read-write      mandatory   
sysName                                 system.5                                DisplayString   read-write      mandatory   
sysLocation                             system.6                                DisplayString   read-write      mandatory   
sysServices                             system.7                                INTEGER         read-only       mandatory   
ifNumber                                interfaces.1                            INTEGER         read-only       mandatory   
ifTable                                 interfaces.2                            SEQUENCE        not-accessible  mandatory   
ifEntry                                 ifTable.1                               SEQUENCE        not-accessible  mandatory   ifIndex
ifIndex                                 ifEntry.1                               INTEGER         read-only       mandatory   
ifDescr                                 ifEntry.2                               DisplayString   read-only       mandatory   
ifType                                  ifEntry.3                               INTEGER         read-only       mandatory   
ifMtu                                   ifEntry.4                               INTEGER         read-only       mandatory   
ifSpeed                                 ifEntry.5                               Gauge           read-only       mandatory   
ifPhysAddress                           ifEntry.6                               PhysAddress     read-only       mandatory   
ifAdminStatus                           ifEntry.7                               INTEGER         read-write      mandatory   
ifOperStatus                            ifEntry.8                               INTEGER         read-only       mandatory   
ifLastChange                            ifEntry.9                               TimeTicks       read-only       mandatory   
ifInOctets                              ifEntry.10                              Counter         read-only       mandatory   
ifInUcastPkts                           ifEntry.11                              Counter         read-only       mandatory   
ifInNUcastPkts                          ifEntry.12                              Counter         read-only       mandatory   
ifInDiscards                            ifEntry.13                              Counter         read-only       mandatory   
ifInErrors                              ifEntry.14                              Counter         read-only       mandatory   
ifInUnknownProtos                       ifEntry.15                              Counter         read-only       mandatory   
ifOutOctets                             ifEntry.16                              Counter         read-only       mandatory   
ifOutUcastPkts                          ifEntry.17                              Counter         read-only       mandatory   
ifOutNUcastPkts                         ifEntry.18                              Counter         read-only       mandatory   
ifOutDiscards                           ifEntry.19                              Counter         read-only       mandatory   
ifOutErrors                             ifEntry.20                              Counter         read-only       mandatory   
ifOutQLen                               ifEntry.21                              Gauge           read-only       mandatory   
ifSpecific                              ifEntry.22                              OBJECT          read-only       mandatory   
-- atTable                                 at.1                                    SEQUENCE        not-accessible  deprecated  
-- atEntry                                 atTable.1                               SEQUENCE        not-accessible  deprecated  atIfIndex atNetAddress
-- atIfIndex                               atEntry.1                               INTEGER         read-write      deprecated  
-- atPhysAddress                           atEntry.2                               PhysAddress     read-write      deprecated  
-- atNetAddress                            atEntry.3                               NetworkAddress  read-write      deprecated  
ipForwarding                            ip.1                                    INTEGER         read-write      mandatory   
ipDefaultTTL                            ip.2                                    INTEGER         read-write      mandatory   
ipInReceives                            ip.3                                    Counter         read-only       mandatory   
ipInHdrErrors                           ip.4                                    Counter         read-only       mandatory   
ipInAddrErrors                          ip.5                                    Counter         read-only       mandatory   
ipForwDatagrams                         ip.6                                    Counter         read-only       mandatory   
ipInUnknownProtos                       ip.7                                    Counter         read-only       mandatory   
ipInDiscards                            ip.8                                    Counter         read-only       mandatory   
ipInDelivers                            ip.9                                    Counter         read-only       mandatory   
ipOutRequests                           ip.10                                   Counter         read-only       mandatory   
ipOutDiscards                           ip.11                                   Counter         read-only       mandatory   
ipOutNoRoutes                           ip.12                                   Counter         read-only       mandatory   
ipReasmTimeout                          ip.13                                   INTEGER         read-only       mandatory   
ipReasmReqds                            ip.14                                   Counter         read-only       mandatory   
ipReasmOKs                              ip.15                                   Counter         read-only       mandatory   
ipReasmFails                            ip.16                                   Counter         read-only       mandatory   
ipFragOKs                               ip.17                                   Counter         read-only       mandatory   
ipFragFails                             ip.18                                   Counter         read-only       mandatory   
ipFragCreates                           ip.19                                   Counter         read-only       mandatory   
ipAddrTable                             ip.20                                   SEQUENCE        not-accessible  mandatory   
ipAddrEntry                             ipAddrTable.1                           SEQUENCE        not-accessible  mandatory   ipAdEntAddr
ipAdEntAddr                             ipAddrEntry.1                           IpAddress       read-only       mandatory   
ipAdEntIfIndex                          ipAddrEntry.2                           INTEGER         read-only       mandatory   
ipAdEntNetMask                          ipAddrEntry.3                           IpAddress       read-only       mandatory   
ipAdEntBcastAddr                        ipAddrEntry.4                           INTEGER         read-only       mandatory   
ipAdEntReasmMaxSize                     ipAddrEntry.5                           INTEGER         read-only       mandatory   
ipRouteTable                            ip.21                                   SEQUENCE        not-accessible  mandatory   
ipRouteEntry                            ipRouteTable.1                          SEQUENCE        not-accessible  mandatory   ipRouteDest
ipRouteDest                             ipRouteEntry.1                          IpAddress       read-write      mandatory   
ipRouteIfIndex                          ipRouteEntry.2                          INTEGER         read-write      mandatory   
ipRouteMetric1                          ipRouteEntry.3                          INTEGER         read-write      mandatory   
ipRouteMetric2                          ipRouteEntry.4                          INTEGER         read-write      mandatory   
ipRouteMetric3                          ipRouteEntry.5                          INTEGER         read-write      mandatory   
ipRouteMetric4                          ipRouteEntry.6                          INTEGER         read-write      mandatory   
ipRouteNextHop                          ipRouteEntry.7                          IpAddress       read-write      mandatory   
ipRouteType                             ipRouteEntry.8                          INTEGER         read-write      mandatory   
ipRouteProto                            ipRouteEntry.9                          INTEGER         read-only       mandatory   
ipRouteAge                              ipRouteEntry.10                         INTEGER         read-write      mandatory   
ipRouteMask                             ipRouteEntry.11                         IpAddress       read-write      mandatory   
ipRouteMetric5                          ipRouteEntry.12                         INTEGER         read-write      mandatory   
ipRouteInfo                             ipRouteEntry.13                         OBJECT          read-only       mandatory   
ipNetToMediaTable                       ip.22                                   SEQUENCE        not-accessible  mandatory   
ipNetToMediaEntry                       ipNetToMediaTable.1                     SEQUENCE        not-accessible  mandatory   ipNetToMediaIfIndex ipNetToMediaNetAddress
ipNetToMediaIfIndex                     ipNetToMediaEntry.1                     INTEGER         read-write      mandatory   
ipNetToMediaPhysAddress                 ipNetToMediaEntry.2                     PhysAddress     read-write      mandatory   
ipNetToMediaNetAddress                  ipNetToMediaEntry.3                     IpAddress       read-write      mandatory   
ipNetToMediaType                        ipNetToMediaEntry.4                     INTEGER         read-write      mandatory   
ipRoutingDiscards                       ip.23                                   Counter         read-only       mandatory   
icmpInMsgs                              icmp.1                                  Counter         read-only       mandatory   
icmpInErrors                            icmp.2                                  Counter         read-only       mandatory   
icmpInDestUnreachs                      icmp.3                                  Counter         read-only       mandatory   
icmpInTimeExcds                         icmp.4                                  Counter         read-only       mandatory   
icmpInParmProbs                         icmp.5                                  Counter         read-only       mandatory   
icmpInSrcQuenchs                        icmp.6                                  Counter         read-only       mandatory   
icmpInRedirects                         icmp.7                                  Counter         read-only       mandatory   
icmpInEchos                             icmp.8                                  Counter         read-only       mandatory   
icmpInEchoReps                          icmp.9                                  Counter         read-only       mandatory   
icmpInTimestamps                        icmp.10                                 Counter         read-only       mandatory   
icmpInTimestampReps                     icmp.11                                 Counter         read-only       mandatory   
icmpInAddrMasks                         icmp.12                                 Counter         read-only       mandatory   
icmpInAddrMaskReps                      icmp.13                                 Counter         read-only       mandatory   
icmpOutMsgs                             icmp.14                                 Counter         read-only       mandatory   
icmpOutErrors                           icmp.15                                 Counter         read-only       mandatory   
icmpOutDestUnreachs                     icmp.16                                 Counter         read-only       mandatory   
icmpOutTimeExcds                        icmp.17                                 Counter         read-only       mandatory   
icmpOutParmProbs                        icmp.18                                 Counter         read-only       mandatory   
icmpOutSrcQuenchs                       icmp.19                                 Counter         read-only       mandatory   
icmpOutRedirects                        icmp.20                                 Counter         read-only       mandatory   
icmpOutEchos                            icmp.21                                 Counter         read-only       mandatory   
icmpOutEchoReps                         icmp.22                                 Counter         read-only       mandatory   
icmpOutTimestamps                       icmp.23                                 Counter         read-only       mandatory   
icmpOutTimestampReps                    icmp.24                                 Counter         read-only       mandatory   
icmpOutAddrMasks                        icmp.25                                 Counter         read-only       mandatory   
icmpOutAddrMaskReps                     icmp.26                                 Counter         read-only       mandatory   
tcpRtoAlgorithm                         tcp.1                                   INTEGER         read-only       mandatory   
tcpRtoMin                               tcp.2                                   INTEGER         read-only       mandatory   
tcpRtoMax                               tcp.3                                   INTEGER         read-only       mandatory   
tcpMaxConn                              tcp.4                                   INTEGER         read-only       mandatory   
tcpActiveOpens                          tcp.5                                   Counter         read-only       mandatory   
tcpPassiveOpens                         tcp.6                                   Counter         read-only       mandatory   
tcpAttemptFails                         tcp.7                                   Counter         read-only       mandatory   
tcpEstabResets                          tcp.8                                   Counter         read-only       mandatory   
tcpCurrEstab                            tcp.9                                   Gauge           read-only       mandatory   
tcpInSegs                               tcp.10                                  Counter         read-only       mandatory   
tcpOutSegs                              tcp.11                                  Counter         read-only       mandatory   
tcpRetransSegs                          tcp.12                                  Counter         read-only       mandatory   
tcpConnTable                            tcp.13                                  SEQUENCE        not-accessible  mandatory   
tcpConnEntry                            tcpConnTable.1                          SEQUENCE        not-accessible  mandatory   tcpConnLocalAddress tcpConnLocalPort tcpConnRemAddress tcpConnRemPort
tcpConnState                            tcpConnEntry.1                          INTEGER         read-write      mandatory   
tcpConnLocalAddress                     tcpConnEntry.2                          IpAddress       read-only       mandatory   
tcpConnLocalPort                        tcpConnEntry.3                          INTEGER         read-only       mandatory   
tcpConnRemAddress                       tcpConnEntry.4                          IpAddress       read-only       mandatory   
tcpConnRemPort                          tcpConnEntry.5                          INTEGER         read-only       mandatory   
tcpInErrs                               tcp.14                                  Counter         read-only       mandatory   
tcpOutRsts                              tcp.15                                  Counter         read-only       mandatory   
udpInDatagrams                          udp.1                                   Counter         read-only       mandatory   
udpNoPorts                              udp.2                                   Counter         read-only       mandatory   
udpInErrors                             udp.3                                   Counter         read-only       mandatory   
udpOutDatagrams                         udp.4                                   Counter         read-only       mandatory   
udpTable                                udp.5                                   SEQUENCE        not-accessible  mandatory   
udpEntry                                udpTable.1                              SEQUENCE        not-accessible  mandatory   udpLocalAddress udpLocalPort
udpLocalAddress                         udpEntry.1                              IpAddress       read-only       mandatory   
udpLocalPort                            udpEntry.2                              INTEGER         read-only       mandatory   
-- egpInMsgs                               egp.1                                   Counter         read-only       mandatory   
-- egpInErrors                             egp.2                                   Counter         read-only       mandatory   
-- egpOutMsgs                              egp.3                                   Counter         read-only       mandatory   
-- egpOutErrors                            egp.4                                   Counter         read-only       mandatory   
-- egpNeighTable                           egp.5                                   SEQUENCE        not-accessible  mandatory   
-- egpNeighEntry                           egpNeighTable.1                         SEQUENCE        not-accessible  mandatory   egpNeighAddr
-- egpNeighState                           egpNeighEntry.1                         INTEGER         read-only       mandatory   
-- egpNeighAddr                            egpNeighEntry.2                         IpAddress       read-only       mandatory   
-- egpNeighAs                              egpNeighEntry.3                         INTEGER         read-only       mandatory   
-- egpNeighInMsgs                          egpNeighEntry.4                         Counter         read-only       mandatory   
-- egpNeighInErrs                          egpNeighEntry.5                         Counter         read-only       mandatory   
-- egpNeighOutMsgs                         egpNeighEntry.6                         Counter         read-only       mandatory   
-- egpNeighOutErrs                         egpNeighEntry.7                         Counter         read-only       mandatory   
-- egpNeighInErrMsgs                       egpNeighEntry.8                         Counter         read-only       mandatory   
-- egpNeighOutErrMsgs                      egpNeighEntry.9                         Counter         read-only       mandatory   
-- egpNeighStateUps                        egpNeighEntry.10                        Counter         read-only       mandatory   
-- egpNeighStateDowns                      egpNeighEntry.11                        Counter         read-only       mandatory   
-- egpNeighIntervalHello                   egpNeighEntry.12                        INTEGER         read-only       mandatory   
-- egpNeighIntervalPoll                    egpNeighEntry.13                        INTEGER         read-only       mandatory   
-- egpNeighMode                            egpNeighEntry.14                        INTEGER         read-only       mandatory   
-- egpNeighEventTrigger                    egpNeighEntry.15                        INTEGER         read-write      mandatory   
-- egpAs                                   egp.6                                   INTEGER         read-only       mandatory   
snmpInPkts                              snmp.1                                  Counter         read-only       mandatory   
snmpOutPkts                             snmp.2                                  Counter         read-only       mandatory   
snmpInBadVersions                       snmp.3                                  Counter         read-only       mandatory   
snmpInBadCommunityNames                 snmp.4                                  Counter         read-only       mandatory   
snmpInBadCommunityUses                  snmp.5                                  Counter         read-only       mandatory   
snmpInASNParseErrs                      snmp.6                                  Counter         read-only       mandatory   
snmpInTooBigs                           snmp.8                                  Counter         read-only       mandatory   
snmpInNoSuchNames                       snmp.9                                  Counter         read-only       mandatory   
snmpInBadValues                         snmp.10                                 Counter         read-only       mandatory   
snmpInReadOnlys                         snmp.11                                 Counter         read-only       mandatory   
snmpInGenErrs                           snmp.12                                 Counter         read-only       mandatory   
snmpInTotalReqVars                      snmp.13                                 Counter         read-only       mandatory   
snmpInTotalSetVars                      snmp.14                                 Counter         read-only       mandatory   
snmpInGetRequests                       snmp.15                                 Counter         read-only       mandatory   
snmpInGetNexts                          snmp.16                                 Counter         read-only       mandatory   
snmpInSetRequests                       snmp.17                                 Counter         read-only       mandatory   
snmpInGetResponses                      snmp.18                                 Counter         read-only       mandatory   
snmpInTraps                             snmp.19                                 Counter         read-only       mandatory   
snmpOutTooBigs                          snmp.20                                 Counter         read-only       mandatory   
snmpOutNoSuchNames                      snmp.21                                 Counter         read-only       mandatory   
snmpOutBadValues                        snmp.22                                 Counter         read-only       mandatory   
snmpOutGenErrs                          snmp.24                                 Counter         read-only       mandatory   
snmpOutGetRequests                      snmp.25                                 Counter         read-only       mandatory   
snmpOutGetNexts                         snmp.26                                 Counter         read-only       mandatory   
snmpOutSetRequests                      snmp.27                                 Counter         read-only       mandatory   
snmpOutGetResponses                     snmp.28                                 Counter         read-only       mandatory   
snmpOutTraps                            snmp.29                                 Counter         read-only       mandatory   
snmpEnableAuthenTraps                   snmp.30                                 INTEGER         read-write      mandatory   
%%


/********************************************************/

#if RTCSCFG_ENABLE_SNMP

#include <rtcs_prv.h>
#include "tcpip.h"
#include "ip_prv.h"
#include "arp_prv.h"
#include "tcp_prv.h"
#include "udp_prv.h"

extern boolean MIB_find_ifEntry(uint_32, pointer, pointer _PTR_);
extern uint_32 MIB_get_ifIndex (pointer interface);
extern uint_32 MIB_get_sysUpTime(pointer);

static uchar IpAddress[4];

static uint_32 MIB_get_snmpInPkts(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->COMMON.ST_RX_TOTAL);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpOutPkts(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->COMMON.ST_TX_TOTAL);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpInBadVersions(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_RX_BAD_VERSION);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpInBadCommunityNames(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_RX_BAD_COMMUNITY);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpInASNParseErrs(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_RX_BAD_PARSE);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpInTotalReqVars(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_RX_VAR_GETS);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpInTotalSetVars(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_RX_VAR_SETS);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpInGetRequests(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_RX_GETREQ);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpInGetNexts(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_RX_GETNEXTREQ);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpInSetRequests(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_RX_SETREQ);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpInGetResponses(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_RX_RESPONSE);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpInTraps(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_RX_TRAP);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpOutTooBigs(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_TX_TOOBIG);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpOutNoSuchNames(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_TX_NOSUCHNAME);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpOutBadValues(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_TX_BADVALUE);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpOutGenErrs(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_TX_GENERR);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpOutGetRequests(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_TX_GETREQ);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpOutGetNexts(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_TX_GETNEXTREQ);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpOutSetRequests(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_TX_SETREQ);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpOutGetResponses(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_TX_RESPONSE);
	#endif
	return(0);	
}

static uint_32 MIB_get_snmpOutTraps(pointer dummy)
{
	#if RTCSCFG_ENABLE_SNMP_STATS
	SNMP_STATS_PTR    SNMP_stats_ptr   = SNMP_get_data();
	return(SNMP_stats_ptr->ST_TX_TRAP);
	#endif
	return(0);	
}

static uint_32 MIB_get_udpNoPorts(pointer dummy)
{
	#if RTCSCFG_ENABLE_UDP_STATS	
	UDP_STATS_PTR    UDP_stats_ptr   = UDP_stats();
	return(UDP_stats_ptr->ST_RX_NO_PORT);
	#endif
	return(0);	
}

static uint_32 MIB_get_udpOutDatagrams(pointer dummy)
{
	#if RTCSCFG_ENABLE_UDP_STATS	
	UDP_STATS_PTR    UDP_stats_ptr   = UDP_stats();
	return(UDP_stats_ptr->COMMON.ST_TX_TOTAL);
	#endif
	return(0);	
}

static uint_32 MIB_get_tcpActiveOpens(pointer dummy)
{
	#if RTCSCFG_ENABLE_TCP_STATS
	TCP_STATS_PTR    TCP_stats_ptr   = TCP_stats();
	return(TCP_stats_ptr->ST_CONN_ACTIVE);
	#endif
	return(0);	
}
 
static uint_32 MIB_get_tcpAttemptFails(pointer dummy)
{
	#if RTCSCFG_ENABLE_TCP_STATS
	TCP_STATS_PTR    TCP_stats_ptr   = TCP_stats();
	return(TCP_stats_ptr->ST_CONN_FAILED);
	#endif
	return(0);	
}

static uint_32 MIB_get_tcpEstabResets(pointer dummy)
{
	#if RTCSCFG_ENABLE_TCP_STATS
	TCP_STATS_PTR    TCP_stats_ptr   = TCP_stats();
	return(TCP_stats_ptr->ST_CONN_RESET);
	#endif
	return(0);	
}

static uint_32 MIB_get_tcpInSegs(pointer dummy)
{
	#if RTCSCFG_ENABLE_TCP_STATS
	TCP_STATS_PTR    TCP_stats_ptr   = TCP_stats();
	return(TCP_stats_ptr->COMMON.ST_RX_TOTAL);
	#endif
	return(0);	
}

static uint_32 MIB_get_tcpRetransSegs(pointer dummy)
{
	#if RTCSCFG_ENABLE_TCP_STATS
	TCP_STATS_PTR    TCP_stats_ptr   = TCP_stats();
	return(TCP_stats_ptr->ST_TX_DATA_DUP);
	#endif
	return(0);	
}

static uint_32 MIB_get_tcpRtoMin(pointer dummy)
{
	return(TCP_RTO_MIN);
}

static uint_32 MIB_get_tcpRtoMax(pointer dummy)
{
	return(2 * TCP_MSL);
}

static uint_32 MIB_get_icmpInMsgs(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->COMMON.ST_RX_TOTAL);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpInErrors(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->COMMON.ST_RX_DISCARDED);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpInDestUnreachs(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_RX_DESTUNREACH);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpInTimeExcds(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_RX_TIMEEXCEED);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpInParmProbs(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_RX_PARMPROB);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpInSrcQuenchs(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_RX_SRCQUENCH);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpInRedirects(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_RX_REDIRECT);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpInEchos(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_RX_ECHO_REQ);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpInEchoReps(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_RX_ECHO_REPLY);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpInTimestamps(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_RX_TIME_REQ);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpInTimestampReps(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_RX_TIME_REPLY);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpInAddrMasks(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_RX_INFO_REQ);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpInAddrMaskReps(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_RX_INFO_REPLY);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpOutMsgs(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->COMMON.ST_TX_TOTAL);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpOutErrors(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->COMMON.ST_TX_DISCARDED);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpOutDestUnreachs(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_TX_DESTUNREACH);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpOutTimeExcds(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_TX_TIMEEXCEED);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpOutParmProbs(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_TX_PARMPROB);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpOutSrcQuenchs(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_TX_SRCQUENCH);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpOutRedirects(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_TX_REDIRECT);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpOutEchos(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_TX_ECHO_REQ);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpOutEchoReps(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_TX_ECHO_REPLY);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpOutTimestamps(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_TX_TIME_REQ);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpOutTimestampReps(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_TX_TIME_REPLY);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpOutAddrMasks(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_TX_INFO_REQ);
	#endif
	return(0);	
}

static uint_32 MIB_get_icmpOutAddrMaskReps(pointer dummy)
{
	#if RTCSCFG_ENABLE_ICMP_STATS
	ICMP_STATS_PTR    ICMP_stats_ptr   = ICMP_stats();
	return(ICMP_stats_ptr->ST_TX_INFO_REPLY);
	#endif
	return(0);	
}

static uint_32 MIB_get_ipReasmTimeout(pointer dummy)
{
	return(IPREASM_TTL);
}

static uint_32 MIB_get_ipInReceives(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->COMMON.ST_RX_TOTAL);
	#endif
	return(0);	
}

static uint_32 MIB_get_ipInHdrErrors(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->ST_RX_HDR_ERRORS);
	#endif
	return(0);		
}

static uint_32 MIB_get_ipInAddrErrors(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->ST_RX_ADDR_ERRORS);
	#endif
	return(0);		
}

static uint_32 MIB_get_ipForwDatagrams(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->ST_RX_FORWARDED);
	#endif
	return(0);		
}

static uint_32 MIB_get_ipInUnknownProtos(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->ST_RX_NO_PROTO);
	#endif
	return(0);		
}

static uint_32 MIB_get_ipInDiscards(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->COMMON.ST_RX_MISSED);
	#endif
	return(0);		
}

static uint_32 MIB_get_ipInDelivers(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->ST_RX_DELIVERED);
	#endif
	return(0);		
}

static uint_32 MIB_get_ipOutRequests(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->COMMON.ST_TX_TOTAL);
	#endif
	return(0);		
}

static uint_32 MIB_get_ipOutDiscards(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->COMMON.ST_TX_MISSED);
	#endif
	return(0);		
}

static uint_32 MIB_get_ipReasmReqds(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->ST_RX_FRAG_RECVD);
	#endif
	return(0);		
}

static uint_32 MIB_get_ipReasmOKs(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->ST_RX_FRAG_REASMD);
	#endif
	return(0);		
}

static uint_32 MIB_get_ipReasmFails(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->ST_RX_FRAG_DISCARDED);
	#endif
	return(0);		
}

static uint_32 MIB_get_ipFragOKs(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->ST_TX_FRAG_FRAGD);
	#endif
	return(0);		
}

static uint_32 MIB_get_ipFragFails(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->ST_TX_FRAG_DISCARDED);
	#endif
	return(0);		
}

static uint_32 MIB_get_ipFragCreates(pointer dummy)
{
	#if RTCSCFG_ENABLE_IP_STATS
	IP_STATS_PTR    IP_stats_ptr   = IP_stats();
	return(IP_stats_ptr->ST_TX_FRAG_SENT);
	#endif
	return(0);		
}

uint_32 MIB_get_sysUpTime (pointer dummy)
{ /* Body */
   TIME_STRUCT uptime;
   _time_get_elapsed(&uptime);
   return (uptime.SECONDS * 100) + (uptime.MILLISECONDS / 10);
} /* Endbody */

static uint_32 MIB_set_dispstr
   (
      uchar_ptr _PTR_ dest,
      uchar_ptr       varptr,
      uint_32         varlen
   )
{ /* Body */
   uchar_ptr dispstr = NULL;

   /* SIZE for DisplayString in MIB is between 0 to 255 */
   if ((varlen + 1) >= 255)
      return SNMP_ERROR_wrongLength;

   if (varlen) {
      dispstr = RTCS_mem_alloc(varlen+1);
      if (!dispstr) {
         return SNMP_ERROR_resourceUnavailable;
      } /* Endif */
      _mem_copy(varptr, dispstr, varlen);
      dispstr[varlen] = '\0';
   } /* Endif */

   if (*dest) {
      _mem_free(*dest);
   } /* Endif */

   *dest = dispstr;
   return SNMP_ERROR_noError;

} /* Endbody */

static uint_32 MIB_set_sysContact (pointer dummy, uchar_ptr varptr, uint_32 varlen)
{ /* Body */
   return MIB_set_dispstr((unsigned char **)(&MIBVALUE_sysContact.PARAM), varptr, varlen);
} /* Endbody */

static uint_32 MIB_set_sysName (pointer dummy, uchar_ptr varptr, uint_32 varlen)
{ /* Body */
   return MIB_set_dispstr((unsigned char **)(&MIBVALUE_sysName.PARAM), varptr, varlen);
} /* Endbody */

static uint_32 MIB_set_sysLocation (pointer dummy, uchar_ptr varptr, uint_32 varlen)
{ /* Body */
   return MIB_set_dispstr((unsigned char **)(&MIBVALUE_sysLocation.PARAM), varptr, varlen);
} /* Endbody */


struct MIB_get_ifNumber_struct {
   uint_32                 current_index;
   IP_CFG_STRUCT_PTR       IP_cfg_ptr;
   IP_ROUTE_DIRECT_PTR     direct;
};

static boolean MIB_get_ifNumber_test2
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   IP_ROUTE_PTR                  route = node_data;
   struct MIB_get_ifNumber_struct _PTR_ testdata = data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->IP_cfg_ptr->IF_LOCALHOST)
   {
      if (testdata->direct == route->DIRECT) {
         testdata->current_index++;
      } /* Endif */

      if (testdata->direct->NETIF == route->DIRECT->NETIF) {
         return TRUE;
      }
   } /* Endif */

   return FALSE;

} /* Endbody */

static boolean MIB_get_ifNumber_test1
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   IP_ROUTE_PTR                  route = node_data;
   struct MIB_get_ifNumber_struct _PTR_ testdata = data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->IP_cfg_ptr->IF_LOCALHOST)
   {
      testdata->direct = route->DIRECT;
      IPRADIX_walk(&testdata->IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ifNumber_test2,
         testdata);
   } /* Endif */

   return FALSE;
} /* Body */

static uint_32 MIB_get_ifNumber (pointer dummy)
{ /* Body */
   IP_CFG_STRUCT_PTR                IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_get_ifNumber_struct   testdata;

   testdata.current_index  = 0;
   testdata.IP_cfg_ptr     = IP_cfg_ptr;
   testdata.direct         = NULL;

   IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ifNumber_test1, &testdata);

   return testdata.current_index;

} /* Endbody */

struct MIB_get_ifif_struct {
   uint_32                 current_index;
   IP_CFG_STRUCT_PTR       IP_cfg_ptr;
   IP_ROUTE_DIRECT_PTR     direct;
   IP_IF_PTR               interface;
   uint_32                 ifindex;
};

static boolean MIB_get_ifif_test2
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   IP_ROUTE_PTR                     route = node_data;
   struct MIB_get_ifif_struct _PTR_ testdata = data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->IP_cfg_ptr->IF_LOCALHOST)
   {
      if (testdata->direct == route->DIRECT) {
         testdata->current_index++;
         if (testdata->ifindex == testdata->current_index) {
            testdata->interface = testdata->direct->NETIF;
            return TRUE;
         } /* Endif */
      } /* Endif */

      if (testdata->direct->NETIF == route->DIRECT->NETIF) {
         return TRUE;
      }
   } /* Endif */

   return FALSE;

} /* Endbody */

static boolean MIB_get_ifif_test1
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   IP_ROUTE_PTR                     route = node_data;
   struct MIB_get_ifif_struct _PTR_ testdata = data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->IP_cfg_ptr->IF_LOCALHOST)
   {
      testdata->direct = route->DIRECT;
      IPRADIX_walk(&testdata->IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ifif_test2,
         testdata);
      if (testdata->interface) {
         return TRUE;
      } /* Endif */
   } /* Endif */

   return FALSE;
} /* Body */

static pointer MIB_get_ifif (uint_32 ifindex)
{ /* Body */
   IP_CFG_STRUCT_PTR          IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_get_ifif_struct testdata;

   testdata.current_index  = 0;
   testdata.IP_cfg_ptr     = IP_cfg_ptr;
   testdata.direct         = NULL;
   testdata.ifindex        = ifindex;
   testdata.interface      = NULL;

   IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ifif_test1, &testdata);

   return testdata.interface;
} /* Endbody */

struct MIB_get_ifIndex_struct {
   uint_32                 current_index;
   IP_CFG_STRUCT_PTR       IP_cfg_ptr;
   IP_ROUTE_DIRECT_PTR     direct;
   IP_IF_PTR               interface;
   uint_32                 ifindex;
};

static boolean MIB_get_ifIndex_test2
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   IP_ROUTE_PTR                        route = node_data;
   struct MIB_get_ifIndex_struct _PTR_ testdata = data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->IP_cfg_ptr->IF_LOCALHOST)
   {
      if (testdata->direct == route->DIRECT) {
         testdata->current_index++;
         if (testdata->interface == testdata->direct->NETIF) {
            testdata->ifindex = testdata->current_index;
            return TRUE;
         } /* Endif */
      } /* Endif */

      if (testdata->direct->NETIF == route->DIRECT->NETIF) {
         return TRUE;
      }
   } /* Endif */

   return FALSE;

} /* Endbody */

static boolean MIB_get_ifIndex_test1
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   IP_ROUTE_PTR                        route = node_data;
   struct MIB_get_ifIndex_struct _PTR_ testdata = data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->IP_cfg_ptr->IF_LOCALHOST)
   {
      testdata->direct = route->DIRECT;
      IPRADIX_walk(&testdata->IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ifIndex_test2,
         testdata);
      if (testdata->ifindex) {
         return TRUE;
      } /* Endif */
   } /* Endif */

   return FALSE;
} /* Body */

uint_32 MIB_get_ifIndex (pointer interface)
{ /* Body */
   IP_CFG_STRUCT_PTR             IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_get_ifIndex_struct testdata;

   testdata.current_index  = 0;
   testdata.IP_cfg_ptr     = IP_cfg_ptr;
   testdata.direct         = NULL;
   testdata.ifindex        = 0;
   testdata.interface      = interface;

   IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ifIndex_test1, &testdata);

   return testdata.ifindex;
} /* Endbody */

static uint_32 MIB_get_ifType (pointer interface) {return ((IP_IF_PTR)interface)->SNMP_IF_TYPE;}
static uint_32 MIB_get_ifMtu  (pointer interface) {return ((IP_IF_PTR)interface)->MTU;}

static uint_32 MIB_get_ifSpeed (pointer interface)
{ /* Body */
   switch (((IP_IF_PTR)interface)->SNMP_IF_TYPE) {
   case IPIFTYPE_ETHERNET:     return 10000000;
   case IPIFTYPE_FASTETHERNET: return 100000000;
   default:                    return 0;
   } /* Endswitch */
} /* Endbody */

static uchar_ptr MIB_get_ifPhysAddress (pointer interface, uint_32 _PTR_ len)
{ /* Body */
   *len = ((IP_IF_PTR)interface)->DEV_ADDRLEN;
   return ((IP_IF_PTR)interface)->DEV_ADDR;
} /* Endbody */

#if RTCSCFG_ENABLE_IPIF_STATS
static uint_32 MIB_get_ifInOctets      (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_RX_OCTETS;}
static uint_32 MIB_get_ifInUcastPkts   (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_RX_UNICAST;}
static uint_32 MIB_get_ifInNUcastPkts  (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_RX_MULTICAST + ((IP_IF_PTR)interface)->STATS.ST_RX_BROADCAST;}
static uint_32 MIB_get_ifInDiscards    (pointer interface) {return ((IP_IF_PTR)interface)->STATS.COMMON.ST_RX_MISSED;}
static uint_32 MIB_get_ifInErrors      (pointer interface) {return ((IP_IF_PTR)interface)->STATS.COMMON.ST_RX_ERRORS;}
static uint_32 MIB_get_ifOutOctets     (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_TX_OCTETS;}
static uint_32 MIB_get_ifOutUcastPkts  (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_TX_UNICAST;}
static uint_32 MIB_get_ifOutNUcastPkts (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_TX_MULTICAST + ((IP_IF_PTR)interface)->STATS.ST_TX_BROADCAST;}
static uint_32 MIB_get_ifOutDiscards   (pointer interface) {return ((IP_IF_PTR)interface)->STATS.COMMON.ST_TX_MISSED;}
static uint_32 MIB_get_ifOutErrors     (pointer interface) {return ((IP_IF_PTR)interface)->STATS.COMMON.ST_TX_ERRORS;}
#else
static uint_32 MIB_get_ifInOctets      (pointer interface) {return 0;}
static uint_32 MIB_get_ifInUcastPkts   (pointer interface) {return 0;}
static uint_32 MIB_get_ifInNUcastPkts  (pointer interface) {return 0;}
static uint_32 MIB_get_ifInDiscards    (pointer interface) {return 0;}
static uint_32 MIB_get_ifInErrors      (pointer interface) {return 0;}
static uint_32 MIB_get_ifOutOctets     (pointer interface) {return 0;}
static uint_32 MIB_get_ifOutUcastPkts  (pointer interface) {return 0;}
static uint_32 MIB_get_ifOutNUcastPkts (pointer interface) {return 0;}
static uint_32 MIB_get_ifOutDiscards   (pointer interface) {return 0;}
static uint_32 MIB_get_ifOutErrors     (pointer interface) {return 0;}
#endif

static RTCSMIB_NODE_PTR MIB_get_ifSpecific (pointer interface)
{ /* Body */
   switch (((IP_IF_PTR)interface)->SNMP_IF_TYPE) {
   default: return NULL;
   } /* Endswitch */
} /* Endbody */

boolean MIB_find_ifEntry
   (
      uint_32        op,
      pointer        index,
      pointer _PTR_  instance
   )
{ /* Body */
   uint_32           ifindex = *(uint_32_ptr)index;
   pointer           interface;

   if ((op == RTCSMIB_OP_GETNEXT) && (ifindex == 0)) {
      ifindex = 1;
   } /* Endif */

   interface = MIB_get_ifif(ifindex);
   if (!interface) {
      return FALSE;
   } /* Endif */
   *(uint_32_ptr)index = ifindex;
   *instance = interface;
   return TRUE;

} /* Endbody */

static uint_32 MIB_set_ifAdminStatus (pointer dummy, uchar_ptr varptr, uint_32 varlen)
{ /* Body */
   int_32 varval = RTCSMIB_int_read(varptr, varlen);
   switch (varval) {
   case 1:  return SNMP_ERROR_noError;
   case 2:
   case 3:  return SNMP_ERROR_inconsistentValue;
   default: return SNMP_ERROR_wrongValue;
   } /* Endswitch */
} /* Endbody */

static uint_32 MIB_get_ipForwarding (pointer dummy) {return _IP_forward ? 1 : 2;}

static uint_32 MIB_get_ipDefaultTTL (pointer dummy)
{ /* Body */
   IP_CFG_STRUCT_PTR IP_cfg_ptr = RTCS_getcfg(IP);
   return IP_cfg_ptr->DEFAULT_TTL;
} /* Endbody */

static uchar_ptr MIB_get_ipAdEntAddr (pointer ipaddr, uint_32 _PTR_ len)
{ /* Body */
   IP_ROUTE_DIRECT_PTR ipaddr_ptr = ipaddr;
   htonl(IpAddress, ipaddr_ptr->ADDRESS);
   *len = 4;
   return IpAddress;
} /* Endbody */

static uint_32 MIB_get_ipAdEntIfIndex (pointer ipaddr)
{ /* Body */
   IP_ROUTE_DIRECT_PTR ipaddr_ptr = ipaddr;
   return MIB_get_ifIndex(ipaddr_ptr->NETIF);
} /* Endbody */

static uchar_ptr MIB_get_ipAdEntNetMask (pointer ipaddr, uint_32 _PTR_ len)
{ /* Body */
   IP_ROUTE_DIRECT_PTR ipaddr_ptr = ipaddr;
   _ip_address         netmask;

   if (IP_get_netmask(ipaddr_ptr->NETIF, ipaddr_ptr->ADDRESS, &netmask)) {
      htonl(IpAddress, netmask);
      *len = 4;
      return IpAddress;
   } /* Endif */

   htonl(IpAddress, 0xFFFFFFFF);
   *len = 4;
   return IpAddress;
} /* Endbody */

struct MIB_get_ipRouteDest_struct {
   _ip_address             netaddr;
   _ip_address             netmask;
   pointer                 iproute;
};

static boolean MIB_get_ipRouteDest_test
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   struct MIB_get_ipRouteDest_struct _PTR_   testdata = data;
   IP_ROUTE_PTR                              route = node_data;
   IP_ROUTE_INDIRECT_PTR                     indirect;
   IP_ROUTE_DIRECT_PTR                       direct;

   if (route && route->DIRECT) {
      direct = route->DIRECT;
      do {
         if (direct == testdata->iproute) {
            testdata->netaddr = route->NODE.IP;
            testdata->netmask = route->NODE.MASK;
            return TRUE;
         } /* Endif */
         direct = direct->NEXT;
      } while (direct != route->DIRECT);
   } /* Endif */

   if (route && route->INDIRECT) {
      indirect = route->INDIRECT;
      do {
         if (indirect == testdata->iproute) {
            testdata->netaddr = route->NODE.IP;
            testdata->netmask = route->NODE.MASK;
            return TRUE;
         } /* Endif */
         indirect = indirect->NEXT;
      } while(indirect != route->INDIRECT);
   } /* Endif */

   return FALSE;
} /* Endbody */


static uchar_ptr MIB_get_ipRouteDest (pointer iproute, uint_32 _PTR_ len)
{ /* Body */
   IP_CFG_STRUCT_PTR                   IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_get_ipRouteDest_struct   testdata;

   testdata.netaddr = INADDR_ANY;
   testdata.iproute = iproute;

   IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ipRouteDest_test, &testdata);

   htonl(IpAddress, testdata.netaddr);
   *len = 4;
   return IpAddress;
} /* Endbody */


static uint_32 MIB_get_ipRouteIfIndex (pointer iproute)
{ /* Body */
   IP_ROUTE_DIRECT_PTR                    direct = iproute;
   IP_ROUTE_INDIRECT_PTR                  indirect = iproute;
   IP_IF_PTR                              ip_interface;
   _ip_address                            if_ip;

   /* If it is a directly connected route */
   if (((IP_ROUTE_INDIRECT_PTR) iproute)->IS_DIRECT) {
      return MIB_get_ifIndex(direct->NETIF);
   } /* Endif */

   /* If it is an indirectly connected route */
   if_ip = IP_route_find(indirect->GATEWAY, IPROUTEOPT_GATE);
   if (if_ip != INADDR_ANY) {
      ip_interface = IP_find_if(if_ip);
      if (ip_interface) {
         return MIB_get_ifIndex(ip_interface);
      } /* Endif */
   } /* Endif */

   return 0;

} /* Endbody */


static uchar_ptr MIB_get_ipRouteNextHop (pointer iproute, uint_32 _PTR_ len)
{ /* Body */
   IP_ROUTE_INDIRECT_PTR iproute_ptr = iproute;
   htonl(IpAddress, iproute_ptr->GATEWAY);
   *len = 4;
   return IpAddress;
} /* Endbody */

static uint_32 MIB_get_ipRouteType (pointer iproute)
{ /* Body */
   IP_ROUTE_INDIRECT_PTR iproute_ptr = iproute;
   if (iproute_ptr->IS_DIRECT)   return 3;
   else                          return 4;
} /* Endbody */

static uchar_ptr MIB_get_ipRouteMask (pointer iproute, uint_32 _PTR_ len)
{ /* Body */
   IP_CFG_STRUCT_PTR                   IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_get_ipRouteDest_struct   testdata;

   testdata.netmask = INADDR_ANY;
   testdata.iproute = iproute;

   IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ipRouteDest_test, &testdata);

   htonl(IpAddress, testdata.netmask);
   *len = 4;
   return IpAddress;
} /* Endbody */

static uint_32 MIB_get_ipNetToMediaIfIndex (pointer arp)
{ /* Body */
   ARP_ENTRY_PTR arp_ptr = arp;
   return MIB_get_ifIndex(arp_ptr->HEAD);
} /* Endbody */

static uchar_ptr MIB_get_ipNetToMediaPhysAddress (pointer arp, uint_32 _PTR_ len)
{ /* Body */
   ARP_ENTRY_PTR arp_ptr = arp;
   *len = 6;
   return arp_ptr->LADDR;
} /* Endbody */

static uchar_ptr MIB_get_ipNetToMediaNetAddress (pointer arp, uint_32 _PTR_ len)
{ /* Body */
   ARP_ENTRY_PTR arp_ptr = arp;
   htonl(IpAddress, arp_ptr->PADDR);
   *len = 4;
   return IpAddress;
} /* Endbody */

struct MIB_find_ipAddrEntry_struct {
   _ip_address             addr;
   IP_ROUTE_DIRECT_PTR     direct;
   _ip_address             netaddr;
   IP_IF_PTR               localhost;
};

static boolean MIB_find_ipAddrEntry_test
   (
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   struct MIB_find_ipAddrEntry_struct _PTR_  testdata = data;
   IP_ROUTE_PTR                              route = node_data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route->DIRECT && route->DIRECT->DESTIF == testdata->localhost) {
      if (route->DIRECT->ADDRESS == testdata->addr) {
         testdata->direct = route->DIRECT;
         return TRUE;
      } /* Endif */
   } /* Endif */

   return FALSE;
} /* Endbody */

static boolean MIB_find_ipAddrEntry_walk
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   struct MIB_find_ipAddrEntry_struct _PTR_  testdata = data;
   IP_ROUTE_PTR                              route = node_data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->localhost)
   {
      if (route->DIRECT->ADDRESS >= testdata->addr) {
         if (testdata->direct == NULL ||
            route->DIRECT->ADDRESS < testdata->direct->ADDRESS)
         {
            testdata->addr = route->DIRECT->ADDRESS;
            testdata->direct = route->DIRECT;
         } /* Endif */
      } /* Endif */
   } /* Endif */

   return FALSE;
} /* Endbody */

boolean MIB_find_ipAddrEntry
   (
      uint_32        op,
      pointer        index,
      pointer _PTR_  instance
   )
{ /* Body */
   IP_CFG_STRUCT_PTR                   IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_find_ipAddrEntry_struct  testdata;

   struct {
      uchar   ipAdEntAddr[4];
   } _PTR_ realindex = index;

   testdata.addr        = ntohl(realindex->ipAdEntAddr);
   testdata.localhost   = IP_cfg_ptr->IF_LOCALHOST;
   testdata.direct      = NULL;

   switch (op) {
   case RTCSMIB_OP_GET:
   case RTCSMIB_OP_SET:
      IPRADIX_findbest(&IP_cfg_ptr->ROUTE_ROOT.NODE, testdata.addr,
         MIB_find_ipAddrEntry_test, &testdata);
      break;

   case RTCSMIB_OP_GETNEXT:
      IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_find_ipAddrEntry_walk, &testdata);
      break;
   } /* Endswitch */

   if (!testdata.direct) {
      return FALSE;
   } /* Endif */

   htonl(realindex->ipAdEntAddr, testdata.direct->ADDRESS);
   *instance = testdata.direct;
   return TRUE;

} /* Endbody */

static boolean MIB_find_ipRouteEntry_test1
   (
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   struct MIB_find_ipAddrEntry_struct _PTR_  testdata = data;
   IP_ROUTE_PTR                              route = node_data;

   if (route->NODE.IP == testdata->addr) {
      testdata->direct = route->DIRECT;
      if (testdata->direct == NULL) {
         testdata->direct = (IP_ROUTE_DIRECT_PTR)((void _PTR_)route->INDIRECT);
         return TRUE;
      } /* Endif */
   } /* Endif */

   return FALSE;
} /* Enbody */

static boolean MIB_find_ipRouteEntry_walk1
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   struct MIB_find_ipAddrEntry_struct _PTR_  testdata = data;
   IP_ROUTE_PTR                              route = node_data;

   if (route) {
      if (node_ip >= testdata->addr) {
         if (testdata->direct == NULL || node_ip < testdata->netaddr) {
            testdata->netaddr = node_ip;
            testdata->direct = route->DIRECT;
            if (testdata->direct == NULL) {
               testdata->direct =
                  (IP_ROUTE_DIRECT_PTR)((void _PTR_)route->INDIRECT);
            } /* Endif */
         }  /* Endif */
      } /* Endif */
   } /* Endif */

   return FALSE;
} /* Endbody */

boolean MIB_find_ipRouteEntry
   (
      uint_32        op,
      pointer        index,
      pointer _PTR_  instance
   )
{ /* Body */
   IP_CFG_STRUCT_PTR                   IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_find_ipAddrEntry_struct  testdata;
   struct {
      uchar   ipRouteDest[4];
   } _PTR_ realindex = index;

   testdata.addr = ntohl(realindex->ipRouteDest);
   testdata.direct = NULL;
   testdata.netaddr = INADDR_ANY;

   switch (op) {
   case RTCSMIB_OP_GET:
   case RTCSMIB_OP_SET:
      /* CR 1822 */
      /*
      IPRADIX_findbest(&IP_cfg_ptr->ROUTE_ROOT.NODE, testdata.addr,
         MIB_find_ipRouteEntry_test1, &testdata);
      break;
      */
      /* End CR 1822 */

   case RTCSMIB_OP_GETNEXT:
      IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_find_ipRouteEntry_walk1, &testdata);
      break;
   } /* Endswitch */

   if (!testdata.direct) {
      return FALSE;
   } /* Endif */

   htonl(realindex->ipRouteDest, testdata.netaddr);
   *instance = testdata.direct;
   return TRUE;

} /* Endbody */

boolean MIB_find_ipNetToMediaEntry
   (
      uint_32        op,
      pointer        index,
      pointer _PTR_  instance
   )
{ /* Body */
   IP_IF_PTR         interface;
   ARP_CFG_PTR       arp_cfg_ptr;
   ARP_ENTRY_PTR     arp_ptr, search_ptr;
   uint_32           ifindex, maxindex, arphash;
   _ip_address       netaddr;
   struct {
      uint_32 ipNetToMediaIfIndex;
      uchar   ipNetToMediaNetAddress[4];
   } _PTR_ realindex = index;

   ifindex = realindex->ipNetToMediaIfIndex;
   netaddr = ntohl(realindex->ipNetToMediaNetAddress);
   maxindex = MIB_get_ifNumber(NULL);

   arp_ptr = NULL;
   switch (op) {
   case RTCSMIB_OP_GET:
   case RTCSMIB_OP_SET:
      interface = MIB_get_ifif(ifindex);
      if (!interface) {
         return FALSE;
      } /* Endif */
      arp_cfg_ptr = interface->ARP;
      if (!arp_cfg_ptr) {
         return FALSE;
      } /* Endif */
      for (arp_ptr = arp_cfg_ptr->CACHE[ARPCACHE_HASH(netaddr)];
           arp_ptr;
           arp_ptr = arp_ptr->NEXT) {
         if (arp_ptr->PADDR == netaddr) {
            break;
         } /* Endif */
      } /* Endfor */
      break;

   case RTCSMIB_OP_GETNEXT:
      for (; ifindex <= maxindex; ifindex++) {
         interface = MIB_get_ifif(ifindex);
         if (!interface) {
            continue;
         } /* Endif */
         arp_cfg_ptr = interface->ARP;
         if (!arp_cfg_ptr) {
            continue;
         } /* Endif */

         for (arphash = 0; arphash < ARPCACHE_SIZE; arphash++) {
            for (search_ptr = arp_cfg_ptr->CACHE[arphash];
                 search_ptr;
                 search_ptr = search_ptr->NEXT) {
               if (search_ptr->PADDR >= netaddr) {
                  if (arp_ptr == NULL) {
                     arp_ptr = search_ptr;
                  } else if (search_ptr->PADDR < arp_ptr->PADDR) {
                     arp_ptr = search_ptr;
                  } /* Endif */
               } /* Endif */
            } /* Endfor */
         } /* Endfor */

         if (arp_ptr) {
            break;
         } /* Endif */

      } /* Endfor */
      break;

   } /* Endswitch */

   if (!arp_ptr) {
      return FALSE;
   } /* Endif */

   realindex->ipNetToMediaIfIndex = ifindex;
   htonl(realindex->ipNetToMediaNetAddress, arp_ptr->PADDR);
   *instance = arp_ptr;
   return TRUE;

} /* Endbody */

uint_32 MIB_set_ipForwarding (pointer dummy, uchar_ptr varptr, uint_32 varlen)
{ /* Body */
   int_32 varval = RTCSMIB_int_read(varptr, varlen);
   switch (varval) {
   case 1: _IP_forward = TRUE;  return SNMP_ERROR_noError;
   case 2: _IP_forward = FALSE; return SNMP_ERROR_noError;
   default: return SNMP_ERROR_wrongValue;
   } /* Endswitch */
} /* Endbody */

uint_32 MIB_set_ipDefaultTTL (pointer dummy, uchar_ptr varptr, uint_32 varlen)
{ /* Body */
   IP_CFG_STRUCT_PTR IP_cfg_ptr = RTCS_getcfg(IP);
   int_32            varval = RTCSMIB_int_read(varptr, varlen);

   if (varval >= 1 && varval <= 255) {
      IP_cfg_ptr->DEFAULT_TTL = varval;
      return SNMP_ERROR_noError;
   } else {
      return SNMP_ERROR_wrongValue;
   } /* Endif */
} /* Endbody */

uint_32 MIB_set_ipRouteDest            (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteIfIndex         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteMetric1         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteMetric2         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteMetric3         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteMetric4         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteMetric5         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteNextHop         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteType            (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteAge             (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteMask            (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipNetToMediaIfIndex    (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipNetToMediaPhysAddress(pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipNetToMediaNetAddress (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipNetToMediaType       (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}

static uint_32 MIB_get_tcpPassiveOpens (pointer dummy)
{ /* Body */
#if RTCSCFG_ENABLE_TCP_STATS
   TCP_CFG_STRUCT_PTR   TCP_cfg_ptr = RTCS_getcfg(TCP);
   TCB_STRUCT_PTR       tcb_ptr;
   uint_32              var;

   var = TCP_cfg_ptr->STATS.ST_CONN_PASSIVE;
   for (tcb_ptr = TCP_cfg_ptr->TCBhead;
        tcb_ptr;
        tcb_ptr = tcb_ptr->next) {
      if (tcb_ptr->state == LISTEN) var--;
   } /* Endfor */
   return var;
#else
   return 0;
#endif
} /* Endbody */

static uint_32 MIB_get_tcpCurrEstab (pointer dummy)
{ /* Body */
   TCP_CFG_STRUCT_PTR   TCP_cfg_ptr = RTCS_getcfg(TCP);
   TCB_STRUCT_PTR       tcb_ptr;
   uint_32              var;

   var = 0;
   for (tcb_ptr = TCP_cfg_ptr->TCBhead;
        tcb_ptr;
        tcb_ptr = tcb_ptr->next) {
      if (tcb_ptr->state == ESTABLISHED) var++;
   } /* Endfor */
   return var;

} /* Endbody */

static  uint_32 MIB_get_tcpOutSegs (pointer dummy)
{ /* Body */
 #if RTCSCFG_ENABLE_TCP_STATS
  TCP_STATS_PTR TCP_stats_ptr = TCP_stats();
   return TCP_stats_ptr->COMMON.ST_TX_TOTAL - TCP_stats_ptr->ST_TX_DATA_DUP;
#else
   return 0;
#endif
} /* Endbody */

static uint_32 MIB_get_tcpConnState (pointer tcb)
{ /* Body */
   switch (((TCB_STRUCT_PTR)tcb)->state) {
   case LISTEN:         return 2;
   case SYN_SENT:       return 3;
   case SYN_RECEIVED:   return 4;
   case ESTABLISHED:    return 5;
   case FINWAIT_1:      return 6;
   case FINWAIT_2:      return 7;
   case CLOSE_WAIT:     return 8;
   case LAST_ACK:       return 9;
   case CLOSING:        return 10;
   case TIME_WAIT:      return 11;
   default:             return 1;
   } /* Endswitch */
} /* Endbody */

static uchar_ptr MIB_get_tcpConnLocalAddress (pointer tcb, uint_32 _PTR_ len)
{ /* Body */
   TCB_STRUCT_PTR tcb_ptr = tcb;
   htonl(IpAddress, tcb_ptr->local_host);
   *len = 4;
   return IpAddress;
} /* Endbody */

static uint_32 MIB_get_tcpConnLocalPort (pointer tcb)
{ /* Body */
   return ((TCB_STRUCT_PTR)tcb)->local_port;
} /* Endbody */

static uchar_ptr MIB_get_tcpConnRemAddress (pointer tcb, uint_32 _PTR_ len)
{ /* Body */
   TCB_STRUCT_PTR tcb_ptr = tcb;
   htonl(IpAddress, tcb_ptr->remote_host);
   *len = 4;
   return IpAddress;
} /* Endbody */

static uint_32 MIB_get_tcpConnRemPort (pointer tcb)
{ /* Body */
   return ((TCB_STRUCT_PTR)tcb)->remote_port;
} /* Endbody */

boolean MIB_find_tcpConnEntry
   (
      uint_32        op,
      pointer        index,
      pointer _PTR_  instance
   )
{ /* Body */
   TCP_CFG_STRUCT_PTR   TCP_cfg_ptr = RTCS_getcfg(TCP);
   TCB_STRUCT_PTR       tcb_ptr, search_ptr;
   _ip_address          locaddr, remaddr;
   uint_16              locport, remport;
   struct {
      uchar   tcpConnLocalAddress[4];
      uint_32 tcpConnLocalPort;
      uchar   tcpConnRemAddress[4];
      uint_32 tcpConnRemPort;
   } _PTR_ realindex = index;

   locaddr = ntohl(realindex->tcpConnLocalAddress);
   locport = realindex->tcpConnLocalPort;
   remaddr = ntohl(realindex->tcpConnRemAddress);
   remport = realindex->tcpConnRemPort;

   tcb_ptr = NULL;
   switch (op) {
   case RTCSMIB_OP_GET:
   case RTCSMIB_OP_SET:
      for (tcb_ptr = TCP_cfg_ptr->TCBhead;
           tcb_ptr;
           tcb_ptr = tcb_ptr->next) {

         if ((tcb_ptr->local_host  == locaddr)
          && (tcb_ptr->local_port  == locport)
          && (tcb_ptr->remote_host == remaddr)
          && (tcb_ptr->remote_port == remport)) {

            break;
         } /* Endif */
      } /* Endfor */
      break;

   case RTCSMIB_OP_GETNEXT:
      for (search_ptr = TCP_cfg_ptr->TCBhead;
           search_ptr;
           search_ptr = search_ptr->next) {

         if ( (search_ptr->local_host >  locaddr)

          || ((search_ptr->local_host == locaddr)
           && (search_ptr->local_port >  locport))

          || ((search_ptr->local_host  == locaddr)
           && (search_ptr->local_port  == locport)
           && (search_ptr->remote_host >  remaddr))

          || ((search_ptr->local_host  == locaddr)
           && (search_ptr->local_port  == locport)
           && (search_ptr->remote_host == remaddr)
           && (search_ptr->remote_port >= remport)) ) {

            if (tcb_ptr == NULL) {
               tcb_ptr = search_ptr;
            } else if ( (search_ptr->local_host <  tcb_ptr->local_host)

                    || ((search_ptr->local_host == tcb_ptr->local_host)
                     && (search_ptr->local_port <  tcb_ptr->local_port))

                    || ((search_ptr->local_host  == tcb_ptr->local_host)
                     && (search_ptr->local_port  == tcb_ptr->local_port)
                     && (search_ptr->remote_host <  tcb_ptr->remote_host))

                    || ((search_ptr->local_host  == tcb_ptr->local_host)
                     && (search_ptr->local_port  == tcb_ptr->local_port)
                     && (search_ptr->remote_host == tcb_ptr->remote_host)
                     && (search_ptr->remote_port <  tcb_ptr->remote_port)) ) {
               tcb_ptr = search_ptr;
            } /* Endif */
         } /* Endif */
      } /* Endfor */
      break;

   } /* Endswitch */

   if (!tcb_ptr) {
      return FALSE;
   } /* Endif */

   htonl(realindex->tcpConnLocalAddress, tcb_ptr->local_host);
   realindex->tcpConnLocalPort = tcb_ptr->local_port;
   htonl(realindex->tcpConnRemAddress, tcb_ptr->remote_host);
   realindex->tcpConnRemPort = tcb_ptr->remote_port;
   *instance = tcb_ptr;
   return TRUE;

} /* Endbody */

static uint_32 MIB_set_tcpConnState(pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}

static uint_32 MIB_get_udpInDatagrams (pointer dummy)
{ /* Body */
#if RTCSCFG_ENABLE_UDP_STATS
   UDP_STATS_PTR UDP_stats_ptr = UDP_stats();
   return UDP_stats_ptr->COMMON.ST_RX_TOTAL - UDP_stats_ptr->COMMON.ST_RX_DISCARDED;
#else
   return 0;
#endif
} /* Endbody */

static uint_32 MIB_get_udpInErrors (pointer dummy)
{ /* Body */
 #if RTCSCFG_ENABLE_UDP_STATS
  UDP_STATS_PTR UDP_stats_ptr = UDP_stats();
   return UDP_stats_ptr->COMMON.ST_RX_DISCARDED - UDP_stats_ptr->ST_RX_NO_PORT;
#else
   return 0;
#endif
} /* Endbody */

static uchar_ptr MIB_get_udpLocalAddress (pointer ucb, uint_32 _PTR_ len)
{ /* Body */
   UCB_STRUCT_PTR ucb_ptr = ucb;
   htonl(IpAddress, ucb_ptr->IPADDR);
   *len = 4;
   return IpAddress;
} /* Endbody */

static uint_32 MIB_get_udpLocalPort (pointer ucb)
{ /* Body */
   return ((UCB_STRUCT_PTR)ucb)->PORT;
} /* Endbody */

boolean MIB_find_udpEntry
   (
      uint_32        op,
      pointer        index,
      pointer _PTR_  instance
   )
{ /* Body */
   UDP_CFG_STRUCT_PTR   UDP_cfg_ptr = RTCS_getcfg(UDP);
   UCB_STRUCT_PTR       ucb_ptr, search_ptr;
   _ip_address          locaddr;
   uint_16              locport;
   struct {
      uchar   udpLocalAddress[4];
      uint_32 udpLocalPort;
   } _PTR_ realindex = index;

   locaddr = ntohl(realindex->udpLocalAddress);
   locport = realindex->udpLocalPort;

   ucb_ptr = NULL;
   switch (op) {
   case RTCSMIB_OP_GET:
   case RTCSMIB_OP_SET:
      RTCS_LIST_SEARCH(UDP_cfg_ptr->OPEN_UCB_HEAD, search_ptr) {
         if ((search_ptr->IPADDR == locaddr)
          && (search_ptr->PORT   == locport)) {
            ucb_ptr = search_ptr;
            break;
         } /* Endif */
      } /* End SEARCH */

      RTCS_LIST_SEARCH(UDP_cfg_ptr->LBOUND_UCB_HEAD, search_ptr) {
         if ((search_ptr->IPADDR == locaddr)
          && (search_ptr->PORT   == locport)) {
            ucb_ptr = search_ptr;
            break;
         } /* Endif */
      } /* End SEARCH */

      RTCS_LIST_SEARCH(UDP_cfg_ptr->BOUND_UCB_HEAD, search_ptr) {
         if ((search_ptr->IPADDR == locaddr)
          && (search_ptr->PORT   == locport)) {
            ucb_ptr = search_ptr;
            break;
         } /* Endif */
      } /* End SEARCH */
      break;
   case RTCSMIB_OP_GETNEXT:
      RTCS_LIST_SEARCH(UDP_cfg_ptr->OPEN_UCB_HEAD, search_ptr) {
         if ((search_ptr->IPADDR >  locaddr)
         || ((search_ptr->IPADDR == locaddr)
          && (search_ptr->PORT   >= locport))) {
            if (ucb_ptr == NULL) {
               ucb_ptr = search_ptr;
            } else if ((search_ptr->IPADDR <  ucb_ptr->IPADDR)
                   || ((search_ptr->IPADDR == ucb_ptr->IPADDR)
                    && (search_ptr->PORT   <  ucb_ptr->PORT))) {
               ucb_ptr = search_ptr;
            } /* Endif */
         } /* Endif */
      } /* End SEARCH */

      RTCS_LIST_SEARCH(UDP_cfg_ptr->LBOUND_UCB_HEAD, search_ptr) {
         if ((search_ptr->IPADDR >  locaddr)
         || ((search_ptr->IPADDR == locaddr)
          && (search_ptr->PORT   >= locport))) {
            if (ucb_ptr == NULL) {
               ucb_ptr = search_ptr;
            } else if ((search_ptr->IPADDR <  ucb_ptr->IPADDR)
                   || ((search_ptr->IPADDR == ucb_ptr->IPADDR)
                    && (search_ptr->PORT   <  ucb_ptr->PORT))) {
               ucb_ptr = search_ptr;
            } /* Endif */
         } /* Endif */
      } /* End SEARCH */

      RTCS_LIST_SEARCH(UDP_cfg_ptr->BOUND_UCB_HEAD, search_ptr) {
         if ((search_ptr->IPADDR >  locaddr)
         || ((search_ptr->IPADDR == locaddr)
          && (search_ptr->PORT   >= locport))) {
            if (ucb_ptr == NULL) {
               ucb_ptr = search_ptr;
            } else if ((search_ptr->IPADDR <  ucb_ptr->IPADDR)
                   || ((search_ptr->IPADDR == ucb_ptr->IPADDR)
                    && (search_ptr->PORT   <  ucb_ptr->PORT))) {
               ucb_ptr = search_ptr;
            } /* Endif */
         } /* Endif */
      } /* End SEARCH */

      break;
   } /* Endswitch */

   if (!ucb_ptr) {
      return FALSE;
   } /* Endif */

   htonl(realindex->udpLocalAddress, ucb_ptr->IPADDR);
   realindex->udpLocalPort = ucb_ptr->PORT;
   *instance = ucb_ptr;
   return TRUE;

} /* Endbody */

uint_32 MIB_set_snmpEnableAuthenTraps
   (
      pointer     dummy,
      uchar_ptr   varptr,
      uint_32     varlen
   )
{ /* Body */
   /* CR 850 */
   int_32 varval = RTCSMIB_int_read(varptr, varlen);
   /* End CR 850 */
   switch (varval) {
   case 1:  return SNMP_ERROR_inconsistentValue;
   case 2:  return SNMP_ERROR_noError;
   default: return SNMP_ERROR_wrongValue;
   } /* Endswitch */
} /* Endbody */

/****************************************************************************/

const RTCSMIB_VALUE MIBVALUE_mib2 = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

/* system */
const RTCSMIB_VALUE MIBVALUE_system = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_sysDescr = {
	RTCSMIB_NODETYPE_DISPSTR_PTR,
	(void _PTR_)SNMPCFG_SYSDESCR
};

const RTCSMIB_VALUE MIBVALUE_sysObjectID = {
	RTCSMIB_NODETYPE_OID_PTR,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_sysUpTime = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_sysUpTime
};

const RTCSMIB_VALUE MIBVALUE_sysContact = {
	RTCSMIB_NODETYPE_DISPSTR_PTR,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_sysName = {
	RTCSMIB_NODETYPE_DISPSTR_PTR,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_sysLocation = {
	RTCSMIB_NODETYPE_DISPSTR_PTR,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_sysServices = {
	RTCSMIB_NODETYPE_UINT_CONST,
	(void _PTR_)SNMPCFG_SYSSERVICES
};

/* interfaces */
const RTCSMIB_VALUE MIBVALUE_interfaces = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ifNumber = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifNumber
};

const RTCSMIB_VALUE MIBVALUE_ifTable = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ifEntry = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ifIndex = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ifDescr = {
	RTCSMIB_NODETYPE_DISPSTR_PTR,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ifType = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifType
};

const RTCSMIB_VALUE MIBVALUE_ifMtu = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifMtu
};

const RTCSMIB_VALUE MIBVALUE_ifSpeed = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifSpeed
};

const RTCSMIB_VALUE MIBVALUE_ifPhysAddress = {
	RTCSMIB_NODETYPE_OCTSTR_FN,
	(RTCSMIB_OCTSTR_FN_PTR)MIB_get_ifPhysAddress
};

const RTCSMIB_VALUE MIBVALUE_ifAdminStatus = {
	RTCSMIB_NODETYPE_UINT_CONST,
	(void _PTR_)1
};

const RTCSMIB_VALUE MIBVALUE_ifOperStatus = {
	RTCSMIB_NODETYPE_UINT_CONST,
	(void _PTR_)1
};

const RTCSMIB_VALUE MIBVALUE_ifLastChange = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ifInOctets = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifInOctets
};

const RTCSMIB_VALUE MIBVALUE_ifInUcastPkts = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifInUcastPkts
};

const RTCSMIB_VALUE MIBVALUE_ifInNUcastPkts = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifInNUcastPkts
};

const RTCSMIB_VALUE MIBVALUE_ifInDiscards = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifInDiscards
};

const RTCSMIB_VALUE MIBVALUE_ifInErrors = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifInErrors
};

const RTCSMIB_VALUE MIBVALUE_ifInUnknownProtos = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ifOutOctets = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifOutOctets
};

const RTCSMIB_VALUE MIBVALUE_ifOutUcastPkts = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifOutUcastPkts
};

const RTCSMIB_VALUE MIBVALUE_ifOutNUcastPkts = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifOutNUcastPkts
};

const RTCSMIB_VALUE MIBVALUE_ifOutDiscards = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifOutDiscards
};

const RTCSMIB_VALUE MIBVALUE_ifOutErrors = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ifOutErrors
};

const RTCSMIB_VALUE MIBVALUE_ifOutQLen = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ifSpecific = {
	RTCSMIB_NODETYPE_OID_FN,
	(RTCSMIB_OID_FN_PTR)MIB_get_ifSpecific
};

/* IP */
const RTCSMIB_VALUE MIBVALUE_ip = {
	RTCSMIB_NODETYPE_INT_CONST,
	(RTCSMIB_OID_FN_PTR)MIB_get_ifSpecific
};

const RTCSMIB_VALUE MIBVALUE_ipForwarding = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_OID_FN_PTR)MIB_get_ipForwarding
};

const RTCSMIB_VALUE MIBVALUE_ipDefaultTTL = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_OID_FN_PTR)MIB_get_ipDefaultTTL
};

const RTCSMIB_VALUE MIBVALUE_ipInReceives = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipInReceives
};

const RTCSMIB_VALUE MIBVALUE_ipInHdrErrors = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipInHdrErrors
};

const RTCSMIB_VALUE MIBVALUE_ipInAddrErrors = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipInAddrErrors
};

const RTCSMIB_VALUE MIBVALUE_ipForwDatagrams = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipForwDatagrams
};

const RTCSMIB_VALUE MIBVALUE_ipInUnknownProtos = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipInUnknownProtos
};

const RTCSMIB_VALUE MIBVALUE_ipInDelivers = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipInDelivers
};

const RTCSMIB_VALUE MIBVALUE_ipOutRequests = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipOutRequests
};

const RTCSMIB_VALUE MIBVALUE_ipOutDiscards = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipOutDiscards
};

const RTCSMIB_VALUE MIBVALUE_ipOutNoRoutes = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipReasmTimeout = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipReasmTimeout
};

const RTCSMIB_VALUE MIBVALUE_ipReasmReqds = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipReasmReqds
};

const RTCSMIB_VALUE MIBVALUE_ipReasmOKs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipReasmOKs
};

const RTCSMIB_VALUE MIBVALUE_ipReasmFails = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipReasmFails
};

const RTCSMIB_VALUE MIBVALUE_ipFragOKs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipFragOKs
};

const RTCSMIB_VALUE MIBVALUE_ipFragFails = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipFragFails
};

const RTCSMIB_VALUE MIBVALUE_ipFragCreates = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipFragCreates
};

const RTCSMIB_VALUE MIBVALUE_ipAddrTable = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipAddrEntry = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipAdEntAddr = {
	RTCSMIB_NODETYPE_OCTSTR_FN,
	(RTCSMIB_OCTSTR_FN_PTR)MIB_get_ipAdEntAddr
};

const RTCSMIB_VALUE MIBVALUE_ipAdEntIfIndex = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipAdEntIfIndex
};

const RTCSMIB_VALUE MIBVALUE_ipAdEntNetMask = {
	RTCSMIB_NODETYPE_OCTSTR_FN,
	(RTCSMIB_OCTSTR_FN_PTR)MIB_get_ipAdEntNetMask
};

const RTCSMIB_VALUE MIBVALUE_ipAdEntBcastAddr = {
	RTCSMIB_NODETYPE_UINT_CONST,
	(void _PTR_)1
};

const RTCSMIB_VALUE MIBVALUE_ipAdEntReasmMaxSize = {
	RTCSMIB_NODETYPE_UINT_CONST,
	(void _PTR_)65535
};

const RTCSMIB_VALUE MIBVALUE_ipRouteTable = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipRouteEntry = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipRouteDest = {
	RTCSMIB_NODETYPE_OCTSTR_FN,
	(RTCSMIB_OCTSTR_FN_PTR)MIB_get_ipRouteDest
};

const RTCSMIB_VALUE MIBVALUE_ipRouteIfIndex = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipRouteIfIndex
};

const RTCSMIB_VALUE MIBVALUE_ipRouteMetric1 = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipRouteMetric2 = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipRouteMetric3 = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipRouteMetric4 = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipRouteNextHop = {
	RTCSMIB_NODETYPE_OCTSTR_FN,
	(RTCSMIB_OCTSTR_FN_PTR)MIB_get_ipRouteNextHop
};

const RTCSMIB_VALUE MIBVALUE_ipRouteType = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipRouteType
};

const RTCSMIB_VALUE MIBVALUE_ipRouteProto = {
	RTCSMIB_NODETYPE_UINT_CONST,
	(void _PTR_)2
};

const RTCSMIB_VALUE MIBVALUE_ipRouteAge = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipRouteMask = {
	RTCSMIB_NODETYPE_OCTSTR_FN,
	(RTCSMIB_OCTSTR_FN_PTR)MIB_get_ipRouteMask
};

const RTCSMIB_VALUE MIBVALUE_ipRouteMetric5 = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipRouteInfo = {
	RTCSMIB_NODETYPE_OID_PTR,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipNetToMediaIfIndex = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_OCTSTR_FN_PTR)MIB_get_ipNetToMediaIfIndex
};

const RTCSMIB_VALUE MIBVALUE_ipNetToMediaPhysAddress = {
	RTCSMIB_NODETYPE_OCTSTR_FN,
	(RTCSMIB_OCTSTR_FN_PTR)MIB_get_ipNetToMediaPhysAddress
};

const RTCSMIB_VALUE MIBVALUE_ipNetToMediaNetAddress = {
	RTCSMIB_NODETYPE_OCTSTR_FN,
	(RTCSMIB_OCTSTR_FN_PTR)MIB_get_ipNetToMediaNetAddress
};

const RTCSMIB_VALUE MIBVALUE_ipNetToMediaType = {
	RTCSMIB_NODETYPE_UINT_CONST,
	(void _PTR_)3
};

const RTCSMIB_VALUE MIBVALUE_ipNetToMediaTable = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipNetToMediaEntry = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_ipRoutingDiscards = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_icmp = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_icmpInMsgs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipInReceives
};

const RTCSMIB_VALUE MIBVALUE_icmpInErrors = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpInErrors
};

const RTCSMIB_VALUE MIBVALUE_icmpInDestUnreachs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpInDestUnreachs
};

const RTCSMIB_VALUE MIBVALUE_icmpInTimeExcds = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpInTimeExcds
};

const RTCSMIB_VALUE MIBVALUE_icmpInParmProbs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpInParmProbs
};

const RTCSMIB_VALUE MIBVALUE_icmpInSrcQuenchs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpInSrcQuenchs
};

const RTCSMIB_VALUE MIBVALUE_icmpInRedirects = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpInRedirects
};

const RTCSMIB_VALUE MIBVALUE_icmpInEchos = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpInEchos
};

const RTCSMIB_VALUE MIBVALUE_icmpInEchoReps = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpInEchoReps
};

const RTCSMIB_VALUE MIBVALUE_icmpInTimestamps = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpInTimestamps
};

const RTCSMIB_VALUE MIBVALUE_icmpInTimestampReps = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpInTimestampReps
};

const RTCSMIB_VALUE MIBVALUE_icmpInAddrMasks = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpInAddrMasks
};

const RTCSMIB_VALUE MIBVALUE_icmpInAddrMaskReps = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpInAddrMaskReps
};

const RTCSMIB_VALUE MIBVALUE_icmpOutMsgs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpOutMsgs
};

const RTCSMIB_VALUE MIBVALUE_icmpOutErrors = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpOutErrors
};

const RTCSMIB_VALUE MIBVALUE_icmpOutDestUnreachs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpOutDestUnreachs
};

const RTCSMIB_VALUE MIBVALUE_icmpOutTimeExcds = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpOutTimeExcds
};

const RTCSMIB_VALUE MIBVALUE_icmpOutParmProbs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpOutParmProbs
};

const RTCSMIB_VALUE MIBVALUE_icmpOutSrcQuenchs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpOutSrcQuenchs
};

const RTCSMIB_VALUE MIBVALUE_icmpOutRedirects = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpOutRedirects
};

const RTCSMIB_VALUE MIBVALUE_icmpOutEchos = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpOutEchos
};

const RTCSMIB_VALUE MIBVALUE_icmpOutEchoReps = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpOutEchoReps
};

const RTCSMIB_VALUE MIBVALUE_icmpOutTimestamps = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpOutTimestamps
};

const RTCSMIB_VALUE MIBVALUE_icmpOutTimestampReps = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpOutTimestampReps
};

const RTCSMIB_VALUE MIBVALUE_icmpOutAddrMasks = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpOutAddrMasks
};

const RTCSMIB_VALUE MIBVALUE_icmpOutAddrMaskReps = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_icmpOutAddrMaskReps
};

const RTCSMIB_VALUE MIBVALUE_tcp = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_tcpRtoAlgorithm = {
	RTCSMIB_NODETYPE_UINT_CONST,
	(void _PTR_)4
};

const RTCSMIB_VALUE MIBVALUE_tcpRtoMin = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_tcpRtoMin
};

const RTCSMIB_VALUE MIBVALUE_tcpRtoMax = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_tcpRtoMax 
};

const RTCSMIB_VALUE MIBVALUE_tcpMaxConn = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_tcpActiveOpens = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_tcpActiveOpens
};

const RTCSMIB_VALUE MIBVALUE_tcpPassiveOpens = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_tcpPassiveOpens
};

const RTCSMIB_VALUE MIBVALUE_tcpAttemptFails = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_tcpAttemptFails
};

const RTCSMIB_VALUE MIBVALUE_tcpEstabResets = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_tcpEstabResets
};

const RTCSMIB_VALUE MIBVALUE_tcpCurrEstab = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_tcpCurrEstab
};

const RTCSMIB_VALUE MIBVALUE_tcpInSegs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_tcpInSegs
};

const RTCSMIB_VALUE MIBVALUE_tcpOutSegs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_tcpOutSegs
};

const RTCSMIB_VALUE MIBVALUE_tcpRetransSegs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_tcpRetransSegs
};

const RTCSMIB_VALUE MIBVALUE_tcpConnState = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_tcpConnState
};

const RTCSMIB_VALUE MIBVALUE_tcpConnLocalAddress = {
	RTCSMIB_NODETYPE_OCTSTR_FN,
	(RTCSMIB_OCTSTR_FN_PTR)MIB_get_tcpConnLocalAddress
};

const RTCSMIB_VALUE MIBVALUE_tcpConnLocalPort = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_tcpConnLocalPort
};

const RTCSMIB_VALUE MIBVALUE_tcpConnRemAddress = {
	RTCSMIB_NODETYPE_OCTSTR_FN,
	(RTCSMIB_OCTSTR_FN_PTR)MIB_get_tcpConnRemAddress
};

const RTCSMIB_VALUE MIBVALUE_tcpConnRemPort = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_tcpConnRemPort
};

const RTCSMIB_VALUE MIBVALUE_tcpConnTable = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_tcpConnEntry = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_tcpInErrs = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_tcpOutRsts = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_udp = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_udpInDatagrams = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_udpInDatagrams
};

const RTCSMIB_VALUE MIBVALUE_udpNoPorts = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_udpNoPorts
};

const RTCSMIB_VALUE MIBVALUE_udpInErrors = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_udpInErrors
};

const RTCSMIB_VALUE MIBVALUE_udpOutDatagrams = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_udpOutDatagrams
};

const RTCSMIB_VALUE MIBVALUE_udpLocalAddress = {
	RTCSMIB_NODETYPE_OCTSTR_FN,
	(RTCSMIB_OCTSTR_FN_PTR)MIB_get_udpLocalAddress
};

const RTCSMIB_VALUE MIBVALUE_udpLocalPort = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_udpLocalPort
};

const RTCSMIB_VALUE MIBVALUE_udpTable = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_udpEntry = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_transmission = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_snmp = {
	RTCSMIB_NODETYPE_INT_CONST,
	NULL
};

const RTCSMIB_VALUE MIBVALUE_snmpInPkts = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpInPkts
};

const RTCSMIB_VALUE MIBVALUE_snmpOutPkts = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpOutPkts
};

const RTCSMIB_VALUE MIBVALUE_snmpInBadVersions = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpInBadVersions
};

const RTCSMIB_VALUE MIBVALUE_snmpInBadCommunityNames = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpInBadCommunityNames
};

const RTCSMIB_VALUE MIBVALUE_snmpInBadCommunityUses = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL  
};

const RTCSMIB_VALUE MIBVALUE_snmpInASNParseErrs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpInASNParseErrs
};

const RTCSMIB_VALUE MIBVALUE_snmpInTooBigs = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL  
};

const RTCSMIB_VALUE MIBVALUE_snmpInNoSuchNames = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL  
};

const RTCSMIB_VALUE MIBVALUE_snmpInBadValues = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL  
};

const RTCSMIB_VALUE MIBVALUE_snmpInReadOnlys = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL  
};

const RTCSMIB_VALUE MIBVALUE_snmpInGenErrs = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL  
};

const RTCSMIB_VALUE MIBVALUE_snmpInTotalReqVars = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpInTotalReqVars
};

const RTCSMIB_VALUE MIBVALUE_snmpInTotalSetVars = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpInTotalSetVars
};

const RTCSMIB_VALUE MIBVALUE_snmpInGetRequests = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpInGetRequests
};

const RTCSMIB_VALUE MIBVALUE_snmpInGetNexts = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpInGetNexts
};

const RTCSMIB_VALUE MIBVALUE_snmpInSetRequests = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpInSetRequests
};

const RTCSMIB_VALUE MIBVALUE_snmpInGetResponses = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpInGetResponses
};

const RTCSMIB_VALUE MIBVALUE_snmpInTraps = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpInTraps
};

const RTCSMIB_VALUE MIBVALUE_snmpOutTooBigs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpOutTooBigs
};

const RTCSMIB_VALUE MIBVALUE_snmpOutNoSuchNames = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpOutNoSuchNames
};

const RTCSMIB_VALUE MIBVALUE_snmpOutBadValues = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpOutBadValues
};

const RTCSMIB_VALUE MIBVALUE_snmpOutGenErrs = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpOutGenErrs
};

const RTCSMIB_VALUE MIBVALUE_snmpOutGetRequests = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpOutGetRequests
};

const RTCSMIB_VALUE MIBVALUE_snmpOutGetNexts = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpOutGetNexts
};

const RTCSMIB_VALUE MIBVALUE_snmpOutSetRequests = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpOutSetRequests
};

const RTCSMIB_VALUE MIBVALUE_snmpOutGetResponses = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpOutGetResponses
};

const RTCSMIB_VALUE MIBVALUE_snmpOutTraps = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_snmpOutTraps
};

const RTCSMIB_VALUE MIBVALUE_snmpEnableAuthenTraps = {
	RTCSMIB_NODETYPE_UINT_CONST,
	NULL  
};

const RTCSMIB_VALUE MIBVALUE_ipInDiscards = {
	RTCSMIB_NODETYPE_UINT_FN,
	(RTCSMIB_UINT_FN_PTR)MIB_get_ipInDiscards
};

#endif /* RTCSCFG_ENABLE_SNMP */

/****************************************************************************/
 
void MIB1213_init(void)
{
#if RTCSCFG_ENABLE_SNMP
   RTCSMIB_mib_add(&MIBNODE_mib2);
#endif
}

/* EOF */
