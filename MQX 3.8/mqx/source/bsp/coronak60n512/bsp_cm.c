/**HEADER***********************************************************************
*
* Copyright (c) 2011 Freescale Semiconductor;
* All Rights Reserved
*
********************************************************************************
*
* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
* THE POSSIBILITY OF SUCH DAMAGE.
*
********************************************************************************
*
* $FileName: bsp_cm.c$
* $Version : 3.8.0.3$
* $Date    : Mar-21-2012$
*
* Comments:
*   Clock manager Kinetis BSP specific definitions and function prototypes.
*
*       _bsp_initialize_hardware();
*       _bsp_set_clock_configuration();
*       _bsp_get_clock_configuration();
*       _bsp_get_clock();
*       _bsp_osc_autotrim();
*
*END***************************************************************************/

#include <mqx.h>
#include <bsp.h>
#include <bsp_prv.h>
#include "mqx_inc.h"


#ifdef PE_LDD_VERSION

extern const TCpuClockConfiguration CpuClockConfigurations[CPU_CLOCK_CONFIG_NUMBER];

#else /* PE_LDD_VERSION */


/* Clock Manager Errors  */
#define ERR_OK          CM_ERR_OK               /* OK */
#define ERR_SPEED       CM_ERR_SPEED            /* This device does not work in the active speed mode. */
#define ERR_RANGE       CM_ERR_RANGE            /* Parameter out of range. */
#define ERR_VALUE       CM_ERR_VALUE            /* Parameter of incorrect value. */
#define ERR_FAILED      CM_ERR_FAILED           /* Requested functionality or process failed. */
#define ERR_PARAM_MODE  CM_ERR_PARAM_MODE       /* Invalid mode. */


#define PE_WFI()        _ASM_WFI()

/* The following code is copied from the code generated by Processor Expert */

/*
** ===================================================================
** Global HAL types and constants
** ===================================================================
*/
typedef uint32_t LDD_TPinMask;         /* Pin mask type. */

typedef uint16_t LDD_TError;           /* Error type. */

typedef uint_32   LDD_TEventMask;       /* Event mask type. */

typedef uint8_t LDD_TClockConfiguration; /* CPU clock configuration type. */

typedef void LDD_TDeviceData;          /* Pointer to private device structure managed and used by HAL components. */
typedef void* LDD_TDeviceDataPtr;      /* Obsolete type for backward compatibility. */

typedef void LDD_TData;                /* General pointer to data. */

typedef void LDD_TUserData;            /* Pointer to this type specifies the user or RTOS specific data will be passed as an event or callback parameter. */

typedef enum {
    DOM_NONE,
    DOM_RUN,
    DOM_WAIT,
    DOM_SLEEP,
    DOM_STOP
} LDD_TDriverOperationMode;            /* Driver operation mode type. */

typedef uint16_t LDD_TDriverState;     /* Driver state type. */

typedef void LDD_TCallbackParam;       /* Pointer to this type specifies the user data to be passed as a callback parameter. */
typedef void (* LDD_TCallback)(LDD_TCallbackParam *CallbackParam); /* Callback type used for definition of callback functions. */



/* Symbols representing MCG modes */
#define MCG_MODE_FBI                    0x00U
#define MCG_MODE_BLPI                   0x01U
#define MCG_MODE_FBE                    0x02U
#define MCG_MODE_PBE                    0x03U
#define MCG_MODE_PEE                    0x04U

/*
 * This matrix defines which mode is next in the MCG Mode state diagram
 * in transitioning from the current mode to a target mode
 */
static const uint8_t MCGTransitionMatrix[5][5] = {
/* FBI  */  {  MCG_MODE_FBI,  MCG_MODE_BLPI,  MCG_MODE_FBE,  MCG_MODE_FBE,  MCG_MODE_FBE},
/* BLPI */  {  MCG_MODE_FBI,  MCG_MODE_BLPI,  MCG_MODE_FBI,  MCG_MODE_FBI,  MCG_MODE_FBI},
/* FBE  */  {  MCG_MODE_FBI,  MCG_MODE_FBI,   MCG_MODE_FBE,  MCG_MODE_PBE,  MCG_MODE_PBE},
/* PBE  */  {  MCG_MODE_FBE,  MCG_MODE_FBE,   MCG_MODE_FBE,  MCG_MODE_PBE,  MCG_MODE_PEE},
/* PEE  */  {  MCG_MODE_PBE,  MCG_MODE_PBE,   MCG_MODE_PBE,  MCG_MODE_PBE,  MCG_MODE_PEE}
};

/*
 * lint -esym(765, CpuClockConfigurations) Disable MISRA rule (8.10) checking for symbols (CpuClockConfigurations).
 */

/*
** ===========================================================================
** The array of clock frequencies in configured clock configurations.
** ===========================================================================
*/
static const TCpuClockConfiguration CpuClockConfigurations[CPU_CLOCK_CONFIG_NUMBER] = {
    /* Clock configuration 0 */
    {
    CPU_CORE_CLK_HZ_CONFIG_0,          /* Core clock frequency in clock configuration 0 */
    CPU_BUS_CLK_HZ_CONFIG_0,           /* Bus clock frequency in clock configuration 0 */
    CPU_FLEXBUS_CLK_HZ_CONFIG_0,       /* Flexbus clock frequency in clock configuration 0 */
    CPU_FLASH_CLK_HZ_CONFIG_0,         /* FLASH clock frequency in clock configuration 0 */
    CPU_USB_CLK_HZ_CONFIG_0,           /* USB clock frequency in clock configuration 0 */
    CPU_PLL_FLL_CLK_HZ_CONFIG_0,       /* PLL/FLL clock frequency in clock configuration 0 */
    CPU_MCGIR_CLK_HZ_CONFIG_0,         /* MCG internal reference clock frequency in clock configuration 0 */
    CPU_OSCER_CLK_HZ_CONFIG_0,         /* System OSC external reference clock frequency in clock configuration 0 */
    CPU_ERCLK32K_CLK_HZ_CONFIG_0,      /* External reference clock 32k frequency in clock configuration 0 */
    CPU_MCGFF_CLK_HZ_CONFIG_0          /* MCG fixed frequency clock */
    },
    /* Clock configuration 1 */
    {
    CPU_CORE_CLK_HZ_CONFIG_1,          /* Core clock frequency in clock configuration 1 */
    CPU_BUS_CLK_HZ_CONFIG_1,           /* Bus clock frequency in clock configuration 1 */
    CPU_FLEXBUS_CLK_HZ_CONFIG_1,       /* Flexbus clock frequency in clock configuration 1 */
    CPU_FLASH_CLK_HZ_CONFIG_1,         /* FLASH clock frequency in clock configuration 1 */
    CPU_USB_CLK_HZ_CONFIG_1,           /* USB clock frequency in clock configuration 1 */
    CPU_PLL_FLL_CLK_HZ_CONFIG_1,       /* PLL/FLL clock frequency in clock configuration 1 */
    CPU_MCGIR_CLK_HZ_CONFIG_1,         /* MCG internal reference clock frequency in clock configuration 1 */
    CPU_OSCER_CLK_HZ_CONFIG_1,         /* System OSC external reference clock frequency in clock configuration 1 */
    CPU_ERCLK32K_CLK_HZ_CONFIG_1,      /* External reference clock 32k frequency in clock configuration 1 */
    CPU_MCGFF_CLK_HZ_CONFIG_1          /* MCG fixed frequency clock */
    },
    /* Clock configuration 2 */
    {
    CPU_CORE_CLK_HZ_CONFIG_2,          /* Core clock frequency in clock configuration 2 */
    CPU_BUS_CLK_HZ_CONFIG_2,           /* Bus clock frequency in clock configuration 2 */
    CPU_FLEXBUS_CLK_HZ_CONFIG_2,       /* Flexbus clock frequency in clock configuration 2 */
    CPU_FLASH_CLK_HZ_CONFIG_2,         /* FLASH clock frequency in clock configuration 2 */
    CPU_USB_CLK_HZ_CONFIG_2,           /* USB clock frequency in clock configuration 2 */
    CPU_PLL_FLL_CLK_HZ_CONFIG_2,       /* PLL/FLL clock frequency in clock configuration 2 */
    CPU_MCGIR_CLK_HZ_CONFIG_2,         /* MCG internal reference clock frequency in clock configuration 2 */
    CPU_OSCER_CLK_HZ_CONFIG_2,         /* System OSC external reference clock frequency in clock configuration 2 */
    CPU_ERCLK32K_CLK_HZ_CONFIG_2,      /* External reference clock 32k frequency in clock configuration 2 */
    CPU_MCGFF_CLK_HZ_CONFIG_2          /* MCG fixed frequency clock */
    }
};

/* Global variables */
static uint8_t ClockConfigurationID = CPU_CLOCK_CONFIG_0; /* Active clock configuration */



/*
** ===================================================================
**     Method      :  LDD_SetClockConfiguration (component MK60N512MD100)
**
**     Description :
**         This method changes the clock configuration of all LDD
**         components in the project.
** ===================================================================
*/
void LDD_SetClockConfiguration(LDD_TClockConfiguration ClockConfiguration)
{
  (void)ClockConfiguration;            /* Parameter is not used, suppress unused argument warning */
}

/*
** ===================================================================
**     Method      :  Cpu_MCGAutoTrim (component MK60N512MD100)
**
**     Description :
**         This method uses MCG auto trim feature to trim internal
**         reference clock. This method can be used only in a clock
**         configuration which derives its bus clock from external
**         reference clock (<MCG mode> must be one of the following
**         modes - FEE, FBE, BLPE, PEE, PBE) and if value of <Bus clock>
**         is in the range <8; 16>MHz.
**         The slow internal reference clock is trimmed to the value
**         selected by <Slow internal reference clock [kHz]> property.
**         The fast internal reference clock will be trimmed to value
**         4MHz.
**     Parameters  :
**         NAME            - DESCRIPTION
**         ClockSelect     - Selects which internal
**                           reference clock will be trimmed.
**                           0 ... slow (32kHz) internal reference clock
**                           will be trimmed
**                           > 0 ... fast (4MHz) internal reference
**                           clock will be trimmed
**     Returns     :
**         ---             - Error code
**                           ERR_OK - OK
**                           ERR_SPEED - The method does not work in the
**                           active clock configuration.
**                           ERR_FAILED - Autotrim process failed.
** ===================================================================
*/
LDD_TError Cpu_MCGAutoTrim(uint8_t ClockSelect)
{
    // NOTE: current clock configuration set by ClockConfigurationID must
    // be using external clock and bus clock must be in the range 8-16MHz.
    switch (ClockConfigurationID) {
    
        case CPU_CLOCK_CONFIG_0:
          if (ClockSelect == 0x00U) {
              // Slow internal reference clock
              // Target clock freq = 32KHz
              // ATCV = 21*(8MHz/32KHz)
                          
              // ATCV value for 12MHz bus clock: 
              //  MCG_ATCVH = 0x1EU;
              //  MCG_ATCVL = 0x0AU;
                
              // ATCV value for 8MHz bus clock:
              MCG_ATCVH = 0x14;
              MCG_ATCVL = 0x82; 
          } else {
              // Fast internal reference clock
              // Target clock freq = 4MHz 
              // ATCV = 21* (8MHz/4MHz)*128 
              
              // ATCV value for 12MHz bus clock:
              //  MCG_ATCVH = 0x1FU;
              //  MCG_ATCVL = 0x80U;
              
              // ATCV value for 8MHz bus clock:              
              MCG_ATCVH = 0x15;
              MCG_ATCVL = 0x00;
          }
          break;
        default:
          return ERR_SPEED;
        }
        if (ClockSelect == 0x00U) {
        /* MCG_SC: ATME=1,ATMS=0,ATMF=0,FLTPRSRV=0,FCRDIV=0,LOCS0=0 */
        MCG_SC = (uint8_t)0x80U;           /* Start trimming of the slow internal reference clock */
        } else {
        /* MCG_SC: ATME=1,ATMS=1,ATMF=0,FLTPRSRV=0,FCRDIV=0,LOCS0=0 */
        MCG_SC = (uint8_t)0xC0U;           /* Start trimming of the fast internal reference clock */
        }
        while ((MCG_SC & MCG_SC_ATME_MASK) != 0x00U) { /* Wait until autotrim completes */
        }
        if ((MCG_SC & MCG_SC_ATMF_MASK) == 0x00U) {
        return ERR_OK;                     /* Trim operation completed successfully */
        } else {
        return ERR_FAILED;                 /* Trim operation failed */
        }
}

/*
** ===================================================================
**     Method      :  Cpu_GetLLSWakeUpFlags (component MK60DN512MD10)
**
**     Description :
**         This method returns the current status of the LLWU wake-up
**         flags indicating which wake-up source caused the MCU to exit
**         LLS or VLLSx low power mode.
**         The following predefined constants can be used to determine
**         the wake-up source:
**         LLWU_EXT_PIN0, ... LLWU_EXT_PIN15 - external pin 0 .. 15
**         caused the wake-up
**         LLWU_INT_MODULE0 .. LLWU_INT_MODULE7 - internal module 0..15
**         caused the wake-up.
**     Parameters  : None
**     Returns     :
**         ---             - Returns the current status of the LLWU
**                           wake-up flags indicating which wake-up
**                           source caused the MCU to exit LLS or VLLSx
**                           low power mode.
** ===================================================================
*/
uint32_t Cpu_GetLLSWakeUpFlags(void)
{
    uint32_t Flags;

    Flags = LLWU_F1;
    Flags |= (uint32_t)((uint32_t)LLWU_F2 << 8U);
    Flags |= (uint32_t)((uint32_t)LLWU_F3 << 16U);
    return Flags;
}

static void Cpu_SetMCGModePEE(uint8_t CLKMode);
/*
** ===================================================================
**     Method      :  Cpu_SetMCGModePEE (component MK60DN512MD10)
**
**     Description :
**         This method sets the MCG to PEE mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/

static void Cpu_SetMCGModePBE(uint8_t CLKMode);
/*
** ===================================================================
**     Method      :  Cpu_SetMCGModePBE (component MK60DN512MD10)
**
**     Description :
**         This method sets the MCG to PBE mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/

static void Cpu_SetMCGModeFBE(uint8_t CLKMode);
/*
** ===================================================================
**     Method      :  Cpu_SetMCGModeFBE (component MK60DN512MD10)
**
**     Description :
**         This method sets the MCG to FBE mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/

static void Cpu_SetMCGModeBLPI(uint8_t CLKMode);
/*
** ===================================================================
**     Method      :  Cpu_SetMCGModeBLPI (component MK60DN512MD10)
**
**     Description :
**         This method sets the MCG to BLPI mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/

static void Cpu_SetMCGModeFBI(uint8_t CLKMode);
/*
** ===================================================================
**     Method      :  Cpu_SetMCGModeFBI (component MK60DN512MD10)
**
**     Description :
**         This method sets the MCG to FBI mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/

static void Cpu_SetMCG(uint8_t CLKMode);
/*
** ===================================================================
**     Method      :  Cpu_SetMCG (component MK60DN512MD10)
**
**     Description :
**         This method updates the MCG according the requested clock 
**         source setting.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/

static uint8_t Cpu_GetCurrentMCGMode(void);
/*
** ===================================================================
**     Method      :  Cpu_GetCurrentMCGMode (component MK60DN512MD10)
**
**     Description :
**         This method returns the active MCG mode
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/

/*
** ===================================================================
**     Method      :  Cpu_SetMCGModePEE (component MK60N512MD100)
**
**     Description :
**         This method sets the MCG to PEE mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void Cpu_SetMCGModePEE(uint8_t CLKMode)
{
    switch (CLKMode) {
        case 0U:
          /* Switch to PEE Mode */
          /* OSC_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
          OSC_CR = (uint8_t)0x00U;                             
          /* MCG_C7: OSCSEL=0 */
          MCG_C7 &= (uint8_t)~(uint8_t)0x01U;                           
          /* MCG_C1: CLKS=0,FRDIV=5,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
          MCG_C1 = (uint8_t)0x28U;                             
          /* MCG_C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=0,LP=0,IRCS=1 */
          MCG_C2 = (uint8_t)0x21U;                             
          /* MCG_C5: ??=0,PLLCLKEN0=0,PLLSTEN0=1,PRDIV0=0x0C */
          MCG_C5 = (uint8_t)0x2CU;                             
          /* MCG_C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=8 */
          MCG_C6 = (uint8_t)0x58U; //0x40; //0x58U;                             
          while((MCG_S & 0x0CU) != 0x0CU) { /* Wait until output of the PLL is selected */
          }
          break;
        default:
          break;
    }
}

/*
** ===================================================================
**     Method      :  Cpu_SetMCGModePBE (component MK60DN512MD10)
**
**     Description :
**         This method sets the MCG to PBE mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void Cpu_SetMCGModePBE(uint8_t CLKMode)
{
    switch (CLKMode) {
        case 0U:
          /* Switch to PBE Mode */
          /* OSC_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
          OSC_CR = (uint8_t)0x00U;                             
          /* MCG_C7: OSCSEL=0 */
          MCG_C7 &= (uint8_t)~(uint8_t)0x01U;                           
          /* MCG_C1: CLKS=2,FRDIV=5,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
          MCG_C1 = (uint8_t)0xA8U;                             
          /* MCG_C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=0,LP=0,IRCS=1 */
          MCG_C2 = (uint8_t)0x21U;                             
          /* MCG_C5: ??=0,PLLCLKEN0=0,PLLSTEN0=1,PRDIV0=0x0C */
          MCG_C5 = (uint8_t)0x2CU;                             
          /* MCG_C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=8 */
          MCG_C6 = (uint8_t)0x58U; //0x40; //0x58U;                            
          while((MCG_S & 0x0CU) != 0x08U) { /* Wait until external reference clock is selected as MCG output */
          }
          while((MCG_S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until locked */
          }
          break;
        case 1U:
          /* Switch to PBE Mode */
          /* OSC_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
          OSC_CR = (uint8_t)0x00U;                             
          /* MCG_C7: OSCSEL=0 */
          MCG_C7 &= (uint8_t)~(uint8_t)0x01U;                           
          /* MCG_C1: CLKS=2,FRDIV=5,IREFS=0,IRCLKEN=1,IREFSTEN=1 */
          MCG_C1 = (uint8_t)0xABU;                             
          /* MCG_C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=0,LP=0,IRCS=1 */
          MCG_C2 = (uint8_t)0x21U;                             
// CATBD - Why PRDIV=0x0D?
          /* MCG_C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0x0D */
          MCG_C5 = (uint8_t)0x0DU;                             
          /* MCG_C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=0 */
          MCG_C6 = (uint8_t)0x58U; //0x40; //0x58U;                         
          while((MCG_S & 0x0CU) != 0x08U) { /* Wait until external reference clock is selected as MCG output */
          }
          while((MCG_S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until locked */
          }
          break;
        default:
          break;
    }
}

/*
** ===================================================================
**     Method      :  Cpu_SetMCGModeFBE (component MK60DN512MD10)
**
**     Description :
**         This method sets the MCG to FBE mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void Cpu_SetMCGModeFBE(uint8_t CLKMode)
{
  switch (CLKMode) {
    case 0U:
      /* Switch to FBE Mode */
      /* OSC_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
      OSC_CR = (uint8_t)0x00U;                             
      /* MCG_C7: OSCSEL=0 */
      MCG_C7 &= (uint8_t)~(uint8_t)0x01U;                           
      /* MCG_C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=0,LP=0,IRCS=1 */
      MCG_C2 = (uint8_t)0x21U;                             
      /* MCG_C1: CLKS=2,FRDIV=5,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
      MCG_C1 = (uint8_t)0xA8U;                             
      /* MCG_C4: DMX32=0,DRST_DRS=0 */
      MCG_C4 &= (uint8_t)~(uint8_t)0xE0U;                           
      /* MCG_C5: ??=0,PLLCLKEN0=0,PLLSTEN0=1,PRDIV0=0xC */
      MCG_C5 = (uint8_t)0x2CU;                             
      /* MCG_C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0x18 */
      MCG_C6 = (uint8_t)0x18U; //0x0; //0x18U;                             
      while((MCG_S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
      }
      while((MCG_S & 0x0CU) != 0x08U) { /* Wait until external reference clock is selected as MCG output */
      }
      break;
    case 1U:
      /* Switch to FBE Mode */
      /* OSC_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
      OSC_CR = (uint8_t)0x00U;                             
      /* MCG_C7: OSCSEL=0 */
      MCG_C7 &= (uint8_t)~(uint8_t)0x01U;                           
      /* MCG_C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=0,LP=0,IRCS=1 */
      MCG_C2 = (uint8_t)0x21U;                             
      /* MCG_C1: CLKS=2,FRDIV=5,IREFS=0,IRCLKEN=1,IREFSTEN=1 */
      MCG_C1 = (uint8_t)0xABU;                             
      /* MCG_C4: DMX32=0,DRST_DRS=0 */
      MCG_C4 &= (uint8_t)~(uint8_t)0xE0U;                           
      /* MCG_C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
      MCG_C5 = (uint8_t)0x00U;                             
      /* MCG_C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=18 */
      MCG_C6 = (uint8_t)0x18U; //0x0; //0x18U;                                
      while((MCG_S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
      }
      while((MCG_S & 0x0CU) != 0x08U) { /* Wait until external reference clock is selected as MCG output */
      }
      break;
    default:
      break;
  }
}

/*
** ===================================================================
**     Method      :  Cpu_SetMCGModeBLPI (component MK60DN512MD10)
**
**     Description :
**         This method sets the MCG to BLPI mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void Cpu_SetMCGModeBLPI(uint8_t CLKMode)
{
  switch (CLKMode) {
    case 1U:
      /* Switch to FEI Mode */
      /* MCG_C1: CLKS=1,FRDIV=0,IREFS=1,IRCLKEN=1,IREFSTEN=1 */
      MCG_C1 = (uint8_t)0x47U;                             
      /* MCG_C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=0,LP=1,IRCS=1 */
      MCG_C2 = (uint8_t)0x23U;                             
      /* OSC_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
      OSC_CR = (uint8_t)0x00U;                             
      while((MCG_S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */
      }
      while((MCG_S & MCG_S_IRCST_MASK) == 0x00U) { /* Check that the fast external reference clock is selected. */
      }
      break;
    default:
      break;
  }
}

/*
** ===================================================================
**     Method      :  Cpu_SetMCGModeFBI (component MK60DN512MD10)
**
**     Description :
**         This method sets the MCG to FBI mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void Cpu_SetMCGModeFBI(uint8_t CLKMode)
{
    switch (CLKMode) {
        case 0U:
          /* Switch to FEI Mode */
          /* MCG_C1: CLKS=1,FRDIV=0,IREFS=1,IRCLKEN=0,IREFSTEN=0 */
          MCG_C1 = (uint8_t)0x44U;                             
          /* MCG_C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=0,LP=0,IRCS=1 */
          MCG_C2 = (uint8_t)0x21U;                             
          /* MCG_C4: DMX32=0,DRST_DRS=0 */
          MCG_C4 &= (uint8_t)~(uint8_t)0xE0U;                           
          /* OSC_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
          OSC_CR = (uint8_t)0x00U;                             
          /* MCG_C7: OSCSEL=0 */
          MCG_C7 &= (uint8_t)~(uint8_t)0x01U;                           
          /* MCG_C5: ??=0,PLLCLKEN0=0,PLLSTEN0=1,PRDIV0=0xC */
          MCG_C5 = (uint8_t)0x2CU;                             
          /* MCG_C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0x18 */
          MCG_C6 = (uint8_t)0x18U; //0x0; //0x18U;                                 
          while((MCG_S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */
          }
          while((MCG_S & 0x0CU) != 0x04U) { /* Wait until internal reference clock is selected as MCG output */
          }
          break;
        case 1U:
          /* Switch to FEI Mode */
          /* MCG_C1: CLKS=1,FRDIV=0,IREFS=1,IRCLKEN=1,IREFSTEN=1 */
          MCG_C1 = (uint8_t)0x47U;                             
          /* MCG_C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=0,LP=0,IRCS=1 */
          MCG_C2 = (uint8_t)0x21U;                             
          /* MCG_C4: DMX32=0,DRST_DRS=0 */
          MCG_C4 &= (uint8_t)~(uint8_t)0xE0U;                    
          /* OSC_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
          OSC_CR = (uint8_t)0x00U;                             
          /* MCG_C7: OSCSEL=0 */
          MCG_C7 &= (uint8_t)~(uint8_t)0x01U;                           
          /* MCG_C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
          MCG_C5 = (uint8_t)0x00U;                             
          /* MCG_C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=18 */
          MCG_C6 = (uint8_t)0x18U; //0x0; //0x18U;                                
          while((MCG_S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */
          }
          while((MCG_S & 0x0CU) != 0x04U) { /* Wait until internal reference clock is selected as MCG output */
          }
          break;
        default:
          break;
    }
}

/*
** ===================================================================
**     Method      :  Cpu_SetMCG (component MK60DN512MD10)
**
**     Description :
**         This method updates the MCG according the requested clock 
**         source setting.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void Cpu_SetMCG(uint8_t CLKMode)
{
    uint8_t TargetMCGMode = 0x00U;
    uint8_t NextMCGMode;

    switch (CLKMode) {
        case 0U:
          TargetMCGMode = MCG_MODE_PEE;
          break;
        case 1U:
          TargetMCGMode = MCG_MODE_BLPI;
          break;
        default:
          break;
    }
    NextMCGMode = Cpu_GetCurrentMCGMode(); /* Identify the currently active MCG mode */
    do {
    NextMCGMode = MCGTransitionMatrix[NextMCGMode][TargetMCGMode]; /* Get the next MCG mode on the path to the target MCG mode */
    switch (NextMCGMode) {             /* Set the next MCG mode on the path to the target MCG mode */
        case MCG_MODE_FBI:
        Cpu_SetMCGModeFBI(CLKMode);
        break;
        case MCG_MODE_BLPI:
        Cpu_SetMCGModeBLPI(CLKMode);
        break;
        case MCG_MODE_FBE:
        Cpu_SetMCGModeFBE(CLKMode);
        break;
        case MCG_MODE_PBE:
        Cpu_SetMCGModePBE(CLKMode);
        break;
        case MCG_MODE_PEE:
        Cpu_SetMCGModePEE(CLKMode);
        break;
        default:
        break;
    }
    } while (TargetMCGMode != NextMCGMode); /* Loop until the target MCG mode is set */
}

/*
** ===================================================================
**     Method      :  Cpu_GetCurrentMCGMode (component MK60DN512MD10)
**
**     Description :
**         This method returns the active MCG mode
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
uint8_t Cpu_GetCurrentMCGMode(void)
{
    switch (MCG_C1  & MCG_C1_CLKS_MASK) {
        case  0x00U:
          return MCG_MODE_PEE;
        case 0x40U:
          /* Internal reference clock is selected */
          if ((MCG_C2 & MCG_C2_LP_MASK) == 0x00U) {
            /* Low power mode is disabled */
            return MCG_MODE_FBI;
          } else {
            /* Low power mode is enabled */
            return MCG_MODE_BLPI;
          }
        case 0x80U:
          if ((MCG_C6 & MCG_C6_PLLS_MASK) == 0x00U) {
            /* FLL is selected */
            return MCG_MODE_FBE;
          } else {
            /* PLL is selected */
            return MCG_MODE_PBE;
           }
        default:
          return 0x00U;
    }
}

static void Cpu_SetRUNMClockDividers( int clk_cfg )
{
    int dly = 200;
    
    switch (clk_cfg)
    {
    case CPU_CLOCK_CONFIG_0:
        // Restore RUNM mode clock divisors
        SIM_CLKDIV1 =  SIM_CLKDIV1_OUTDIV1(WHISTLE_CONFIG0_CORE_DIV) | 
                       SIM_CLKDIV1_OUTDIV2(WHISTLE_CONFIG0_BUS_DIV) | 
                       SIM_CLKDIV1_OUTDIV3(BSP_FLEXBUS_DIV) | 
                       SIM_CLKDIV1_OUTDIV4(WHISTLE_CONFIG0_FLASH_DIV);  
        // USB Clock Dividers
        SIM_CLKDIV2 = (uint32_t)( SIM_CLKDIV2_USBDIV( WHISTLE_CONFIG0_USB_DIV ) | WHISTLE_CONFIG0_USB_FRAC );
        break;
    case CPU_CLOCK_CONFIG_1:
        // TODO: change these to CONFIG_1 settings:
        
        // Restore RUNM mode clock divisors
        SIM_CLKDIV1 =  SIM_CLKDIV1_OUTDIV1(WHISTLE_CONFIG1_CORE_DIV) | 
                       SIM_CLKDIV1_OUTDIV2(WHISTLE_CONFIG1_BUS_DIV) | 
                       SIM_CLKDIV1_OUTDIV3(BSP_FLEXBUS_DIV) | 
                       SIM_CLKDIV1_OUTDIV4(WHISTLE_CONFIG1_FLASH_DIV);  
        // USB Clock Dividers
        SIM_CLKDIV2 = (uint32_t)( SIM_CLKDIV2_USBDIV( WHISTLE_CONFIG1_USB_DIV ) | WHISTLE_CONFIG1_USB_FRAC );
        break;
    default:
        break;
    }

    // Wait for clocks to stabilise 
    do {
        asm("NOP");
    } while (--dly);
}

/*
 * Switch clock mode from FBI (internal clock) FEE (ext. clock + FLL)
 * Only CONFIG0 and CONFIG1 are allowed for the clk_cfg parameter.
 */
static void Cpu_Fbi2Fee( int clk_cfg )
{   
    volatile uint8_t regval;
    MCG_C7 |= MCG_C7_OSCSEL_MASK;
   
    // Disable the LP bit before the setting the DMX32 bit
    MCG_C2 &= ~MCG_C2_LP_MASK; 
  
    // Select DCO fine-tune mode   
    regval = MCG_C4 & (uint8_t)~((uint8_t)MCG_C4_DRST_DRS_MASK);
    if ( CPU_CLOCK_CONFIG_0 == clk_cfg )
    {
        regval |= MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS(WHISTLE_CONFIG0_DRST_DRS);
    }
    else
    {
        regval |= MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS(WHISTLE_CONFIG1_DRST_DRS);        
    }
    MCG_C4 = regval;        
    
    // Set FCRDIV=1 (internal clock divider)
    MCG_SC &= ~(MCG_SC_FCRDIV_MASK);
    // Select fast internal RC clock
    MCG_SC |= MCG_SC_ATMS_MASK;
  
    // Select the Low Frequency range  for the 32KHz RTC clock
    // Enable the External reference and Low power bits
    MCG_C2 = MCG_C2_RANGE0(0); 

    // Select the FLL output
    MCG_C1 = MCG_C1_CLKS(0);
  
    // Enable the External Reference clock
    MCG_C1 &= ~MCG_C1_IREFS_MASK; 
    
    // Poll MCG status register until the External Reference clock is selected
    while ((MCG_S & MCG_S_IREFST_MASK)){};  
  
    // Poll MCG status register until FLL is selected as clock output
    while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0){};
}

static void Cpu_Blpi2Fbi(void)
{
    MCG_C2 &= ~MCG_C2_LP_MASK;  

    // Wait for Internal Reference Status bit to update.
    while (!(MCG_S & MCG_S_IREFST_MASK)){};  

    // Wait for clock status bits to update 
    while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1){};   
}

static void Cpu_Fee2Fbi(void)
{
    // Select lowest frequency range for the crystal oscillator / ext. clock input
    MCG_C2 = MCG_C2_RANGE0(0);
  
    // Set the clock source to the FLL output,
    MCG_C1 = MCG_C1_IREFS_MASK | MCG_C1_CLKS(0);       
    
    // Select DCO wide range frequency tuning using DRST_DRS field 
    MCG_C4 &= ~( MCG_C4_DMX32_MASK | MCG_C4_DMX32_MASK);

    // Poll MCG status register until FLL source is the fast IRC
    while (!(MCG_S & MCG_S_IREFST_MASK))
        ;
  
    // Poll the MCG status register until the low IRC clock is selected
    while ((MCG_S & MCG_S_IRCST_MASK))
        ;
}


static void Cpu_Fbi2Blpi( int irc_speed )
{
    int dly = 63;
    
    // Select slow (32KHz) or fast (4MHz) internal osc.
    if ( irc_speed )
    {
        //Set the High Frequency Range, Low Power bit to disable the FLL, select fast IRC
        MCG_C2 = MCG_C2_RANGE0(1) | MCG_C2_IRCS_MASK | MCG_C2_LP_MASK;
    }
    else
    {
        //Set the Low Frequency Range, Low Power bit to disable the FLL, select fast IRC
        MCG_C2 = MCG_C2_RANGE0(0) | MCG_C2_LP_MASK;
    }
    MCG_C1 = MCG_C1_CLKS(1); // select IRC (internal reference clock) as MCG clock
  
    // Poll the MCG status register and wait until clock read bit is set
    while ( ((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1 )
        ;  
    
    // Wait for clocks to stabilise 
    do {
        asm("NOP");
    } while (--dly);
}


/*
** ===================================================================
**     Method      :  Cpu_SetClockConfiguration (component MK60DN512MD10)
**
**     Description :
**         Calling of this method will cause the clock configuration
**         change and reconfiguration of all components according to
**         the requested clock configuration setting.
**     Parameters  :
**         NAME            - DESCRIPTION
**         ModeID          - Clock configuration identifier
**     Returns     :
**         ---             - ERR_OK - OK.
**                           ERR_RANGE - Mode parameter out of range
** ===================================================================
*/
LDD_TError Cpu_SetClockConfiguration(LDD_TClockConfiguration ModeID)
{   
    if (ModeID > CPU_CLOCK_CONFIG_2) 
    {
        return ERR_RANGE;                  /* Undefined clock configuration requested requested */
    }
    
    switch (ModeID) 
    {
        case CPU_CLOCK_CONFIG_0:
            if ( ClockConfigurationID == CPU_CLOCK_CONFIG_2 )
            { 
                // Current MCG mode is BLPI: switch to FEE mode to use external clock
                
                // Disable the clock monitor: MCG_C6: CME0=0
                MCG_C6 &= (uint8_t)~(uint8_t)0x20U; 
                
                // Use new clock switch functions
                Cpu_Blpi2Fbi();
                Cpu_Fbi2Fee(CPU_CLOCK_CONFIG_0);
                
                // Enable the clock monitor: MCG_C6: CME0=1 
                //MCG_C6 |= (uint8_t)0x20U;  
            }
                
            // Set the clock dividers for CONFIG_0
            Cpu_SetRUNMClockDividers( CPU_CLOCK_CONFIG_0 );
                        
            // Select the FLL. SIM_SOPT2: PLLFLLSEL=0 (FLL)
            SIM_SOPT2 &= (uint32_t)~(uint32_t)0x00010000UL;        
                                    
            // Silego 32KHz clock is input to K60 EXTAL32/XTAL32 pins.
            // Select 32.768KHz RTC oscillator as the input. SSIM_SOPT1: OSC32KSEL=2
            SIM_SOPT1 = (uint32_t)((SIM_SOPT1 & (uint32_t)~0x00040000UL) | (uint32_t)0x00080000UL); 
            break;
            
        case CPU_CLOCK_CONFIG_1:
            if ( ClockConfigurationID == CPU_CLOCK_CONFIG_2 )
            { 
                // Current MCG mode is BLPI: switch to FEE mode to use external clock
                
                // Disable the clock monitor: MCG_C6: CME0=0
                MCG_C6 &= (uint8_t)~(uint8_t)0x20U; 
                
                // Use new clock switch functions
                Cpu_Blpi2Fbi();
                Cpu_Fbi2Fee(CPU_CLOCK_CONFIG_1);
                
                // Enable the clock monitor: MCG_C6: CME0=1 
                //MCG_C6 |= (uint8_t)0x20U;  
            }
            
            // Set the clock dividers for CONFIG_1
            Cpu_SetRUNMClockDividers( CPU_CLOCK_CONFIG_1 );        
                        
            // Select the FLL. SIM_SOPT2: PLLFLLSEL=0 (FLL)
            SIM_SOPT2 &= (uint32_t)~(uint32_t)0x00010000UL;        
                                    
            // Silego 32KHz clock is input to K60 EXTAL32/XTAL32 pins.
            // Select 32.768KHz RTC oscillator as the input. SSIM_SOPT1: OSC32KSEL=2
            SIM_SOPT1 = (uint32_t)((SIM_SOPT1 & (uint32_t)~0x00040000UL) | (uint32_t)0x00080000UL); 
            break;
    
        case CPU_CLOCK_CONFIG_2:    
        	if ( ClockConfigurationID != CPU_CLOCK_CONFIG_2 )
        	{
        	    // Current MCG mode is FEE: switch to BLPI mode to use internal fast clock
        	    
                // Disable the clock monitor: MCG_C6: CME0=0
                MCG_C6 &= (uint8_t)~(uint8_t)0x20U;         	
                Cpu_Fee2Fbi();  // First, transition from FEE to FBI clock mode
                Cpu_Fbi2Blpi(1); // Now, transition from FBI to BLPI clock mode w/ fast IRC selected
        	}
        	
            // VLPR Clock Dividers (System clock source is the 4MHz Fast IRC clock)
            SIM_CLKDIV1 =  SIM_CLKDIV1_OUTDIV1(VLPR_CORE_DIV) | 
                           SIM_CLKDIV1_OUTDIV2(VLPR_BUS_DIV) | 
                           SIM_CLKDIV1_OUTDIV3(VLPR_FLEXBUS_DIV) | 
                           SIM_CLKDIV1_OUTDIV4(VLPR_FLASH_DIV);  
            
            // USB Clock Dividers  (USB cannot be used in VLPR mode)
            SIM_CLKDIV2 &= (uint32_t)~0x0FUL;
        	break;     
        default:
          break;
    }
    LDD_SetClockConfiguration(ModeID);   /* Call all LDD components to update the clock configuration */
    ClockConfigurationID = ModeID;       /* Store clock configuration identifier */
    return ERR_OK;
}

/*
** ===================================================================
**     Method      :  Cpu_GetClockConfiguration (component MK60DN512MD10)
**
**     Description :
**         Returns the active clock configuration identifier. The
**         method is enabled only if more than one clock configuration
**         is enabled in the component.
**     Parameters  : None
**     Returns     :
**         ---             - Active clock configuration identifier
** ===================================================================
*/
uint8_t Cpu_GetClockConfiguration(void)
{
  return ClockConfigurationID;         /* Return the actual clock configuration identifier */
}

/*
** ===================================================================
**     Method      :  Cpu_SetOperationMode (component MK60N512MD100)
**
**     Description :
**         This method requests to change the component's operation
**         mode (RUN, WAIT, SLEEP, STOP). The target operation mode
**         will be entered immediately. The ModeChangeCallback
**         parameter will is ignored (only for interface compatibility
**         reasons).
**         If the settings of the active clock configuration doesn't
**         comply with the target operation mode requirements (e.g. MCG
**         setting is not valid) the ERR_SPEED value is returned and no
**         change of operation mode is done.
**     Parameters  :
**         NAME            - DESCRIPTION
**         OperationMode   - Requested driver
**                           operation mode
**         ModeChangeCallback - Parameter is
**                           ignored, only for compatibility of API with
**                           other components.
**       * ModeChangeCallbackParamPtr
**                           - Pointer to callback parameter to notify
**                           the upper layer once a mode has been
**                           changed.
**     Returns     :
**         ---             - Error code
**                           ERR_OK - OK
**                           ERR_PARAM_MODE - Invalid operation mode
** ===================================================================
*/
LDD_TError Cpu_SetOperationMode(LDD_TDriverOperationMode OperationMode, LDD_TCallback ModeChangeCallback, LDD_TCallbackParam *ModeChangeCallbackParamPtr)
{
    (void) ModeChangeCallback;           /* Parameter is not used, suppress unused argument warning */
    (void) ModeChangeCallbackParamPtr;   /* Parameter is not used, suppress unused argument warning */
    switch (OperationMode) {
        case DOM_RUN:
          /* SCB_SCR: SLEEPDEEP=0,SLEEPONEXIT=0 */
          SCB_SCR &= (uint32_t)~0x06UL;
          if  (ClockConfigurationID != 2U) {
            if ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) { /* If in PBE mode, switch to PEE. PEE to PBE transition was caused by wakeup from low power mode. */
              /* MCG_C1: CLKS=0,IREFS=0 */
              MCG_C1 &= (uint8_t)~(uint8_t)0xC4U;
              while( (MCG_S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait for PLL lock */
              }
            }
          }
          break;
        case DOM_WAIT:
          /* SCB_SCR: SLEEPDEEP=0 */
          SCB_SCR &= (uint32_t)~0x04UL;
          /* SCB_SCR: SLEEPONEXIT=0 */
          SCB_SCR &= (uint32_t)~0x02UL;
          PE_WFI();
          break;
        case DOM_SLEEP:
          /* SCB_SCR: SLEEPDEEP=1 */
          SCB_SCR |= (uint32_t)0x04UL;
          /* MC_PMCTRL: LPLLSM=0 */
          SMC_PMCTRL &= (uint8_t)~(uint8_t)0x07U;
          /* SCB_SCR: SLEEPONEXIT=1 */
          SCB_SCR |= (uint32_t)0x02UL;
          PE_WFI();
          break;
        case DOM_STOP:
          /* Clear LLWU flags */
          /* LLWU_F1: WUF7=1,WUF6=1,WUF5=1,WUF4=1,WUF3=1,WUF2=1,WUF1=1,WUF0=1 */
          LLWU_F1 = (uint8_t)0xFFU;
          /* LLWU_F2: WUF15=1,WUF14=1,WUF13=1,WUF12=1,WUF11=1,WUF10=1,WUF9=1,WUF8=1 */
          LLWU_F2 = (uint8_t)0xFFU;
          /* LLWU_F3: MWUF7=1,MWUF6=1,MWUF5=1,MWUF4=1,MWUF3=1,MWUF2=1,MWUF1=1,MWUF0=1 */
          LLWU_F3 = (uint8_t)0xFFU;
          /* SCB_SCR: SLEEPONEXIT=0 */
          SCB_SCR &= (uint32_t)~0x02UL;
          /* SCB_SCR: SLEEPDEEP=1 */
          SCB_SCR |= (uint32_t)0x04UL;
          /* MC_PMCTRL: LPLLSM=3 */
          SMC_PMCTRL = (uint8_t)((SMC_PMCTRL & (uint8_t)~(uint8_t)0x04U) | (uint8_t)0x03U);
          PE_WFI();
          break;
        default:
        return ERR_PARAM_MODE;
    }
    return ERR_OK;
}

/*
** ===================================================================
**     Method      :  __pe_initialize_hardware (component MK60N512MD100)
**
**     Description :
**         Initializes the whole system like timing, external bus, etc.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/

void _bsp_initialize_hardware(void)
{
    volatile uint8_t regval;
#if 0 //COR_174_WORKAROUND
    uint32_t mcm_cr;
#endif
    
    _bsp_watchdog_disable();
    
    /* Whistle uses 32 KHz clock attached to RTC instead of System Oscillator. */
    /* Set RTC up here. */
    /* SIM_SCGC6: RTC=1 */
    SIM_SCGC6 |= SIM_SCGC6_RTC_MASK;                                                   
    if ((RTC_CR & RTC_CR_OSCE_MASK) == 0u) { /* Only if the OSCILLATOR is not already enabled */
      /* RTC_CR: SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
      RTC_CR &= (uint32_t)~(uint32_t)(
                 RTC_CR_SC2P_MASK |
                 RTC_CR_SC4P_MASK |
                 RTC_CR_SC8P_MASK |
                 RTC_CR_SC16P_MASK
                );                                                   
      /* RTC_CR: OSCE=1 */
      RTC_CR |= RTC_CR_OSCE_MASK;                                                   
      /* RTC_CR: CLKO=0 */
      RTC_CR &= (uint32_t)~(uint32_t)(RTC_CR_CLKO_MASK);                                                   
    }

    /* System clock initialization */
    /* SIM_SCGC5: PORTE=1,PORTD=1,PORTC=1,PORTB=1,PORTA=1 */
    SIM_SCGC5 |= SIM_SCGC5_PORTE_MASK |
                 SIM_SCGC5_PORTD_MASK |
                 SIM_SCGC5_PORTC_MASK |
                 SIM_SCGC5_PORTB_MASK |
                 SIM_SCGC5_PORTA_MASK;   /* Enable clock gate for ports to enable pin routing */
    
#if 0
    
    // Moving this to later in the boot, because we actually still need the 26mhz up and going
    // at this point!
    
    /*
     *   Ernie:  Turn off 26MHz_MCU_EN clock (PTC19 enable).  
     *           It must never be used in the app due to high power.
     */
    PORTC_PCR19 = (uint32_t)((PORTC_PCR19 & (uint32_t)~(uint32_t)(
                   PORT_PCR_ISF_MASK |
                   PORT_PCR_MUX(0x06)
                  )) | (uint32_t)(
                   PORT_PCR_MUX(0x01)
                  ));
    GPIOC_PSOR |= GPIO_PSOR_PTSO(0x00080000);                                   
    GPIOC_PCOR &= (uint32_t)~(uint32_t)(GPIO_PCOR_PTCO(0x00080000));
    GPIOC_PDDR |= GPIO_PDDR_PDD(0x00080000);
    GPIOC_PDOR &= ~0x00080000;
#endif
    
    /*
     *   Ernie:  Get rid of FlexBus Clock.  We do not need it!
     */
    SIM_SCGC7 &= ~(0x1);

    SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV4( WHISTLE_CONFIG0_FLASH_DIV ); /* Update system prescalers */
   
    /* SIM_SOPT2: PLLFLLSEL=0 */
    SIM_SOPT2 &= (uint32_t)~(uint32_t)(SIM_SOPT2_PLLFLLSEL_MASK); /* Select FLL as a clock source for various peripherals */
    /* SIM_SOPT1: OSC32KSEL=0 */
    SIM_SOPT1 &= (uint32_t)~(uint32_t)(SIM_SOPT1_OSC32KSEL(0x03)); /* System oscillator drives 32 kHz clock for various peripherals */
    /* Switch to FEE Mode */
    /* MCG_C2: LOCRE0=0,??=0,RANGE0=0,HGO0=0,EREFS0=0,LP=0,IRCS=0 */
    MCG_C2 = 0x00U;                                                   
    /* OSC_CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
    OSC_CR = OSC_CR_ERCLKEN_MASK;                                                   
    /* MCG_C7: OSCSEL=1 */
    MCG_C7 |= MCG_C7_OSCSEL_MASK;                                                   
    /* MCG_C1: CLKS=0,FRDIV=0,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
    MCG_C1 = 0x00;; 
    
    /*
     *   Whistle FLL configured here.
     *   Whistle uses DMX32 = 1 for RUNM mode and DRST for the desired core frequency 
     */
    regval = MCG_C4 & (uint8_t)~((uint8_t)MCG_C4_DRST_DRS_MASK);
    regval |= MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS(WHISTLE_CONFIG0_DRST_DRS);
    MCG_C4 = regval;                     
    
    // Set FCRDIV=1 (internal clock divider)
    MCG_SC &= ~(MCG_SC_FCRDIV_MASK);
    // Select fast internal RC clock
    MCG_SC |= MCG_SC_ATMS_MASK;
    
    /* MCG_C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
    MCG_C5 = 0x00U;                                                   
    /* MCG_C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=18 */
    MCG_C6 = (uint8_t)0x18U; //0x0; //0x18U;                                            
    while((MCG_S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
    }
    while((MCG_S & 0x0CU) != 0x00U) {    /* Wait until output of the FLL is selected */
    }
    
    /*
     *   Ernie:  Change the SRAM priority to favor DMA ("backdoor") over the Processor.
     *           Using "give more priority to DMA" mode.
     */
#if 0 //COR_174_WORKAROUND
    mcm_cr = MCM_CR;
    mcm_cr &= (uint32_t) ~( MCM_CR_SRAMUAP_MASK | MCM_CR_SRAMLAP_MASK );
    mcm_cr |= (uint32_t) ( MCM_CR_SRAMUAP(0x1) | MCM_CR_SRAMLAP(0x1) );
    MCM_CR = mcm_cr;
#endif
    
    /*
     *   Ernie:  Turn off 26MHz_MCU_EN clock (PTC19 enable).  
     *           It must never be used in the app due to high power.
     */
    PORTC_PCR19 = (uint32_t)((PORTC_PCR19 & (uint32_t)~(uint32_t)(
                   PORT_PCR_ISF_MASK |
                   PORT_PCR_MUX(0x06)
                  )) | (uint32_t)(
                   PORT_PCR_MUX(0x01)
                  ));
    GPIOC_PSOR |= GPIO_PSOR_PTSO(0x00080000);                                   
    GPIOC_PCOR &= (uint32_t)~(uint32_t)(GPIO_PCOR_PTCO(0x00080000));
    GPIOC_PDDR |= GPIO_PDDR_PDD(0x00080000);
    GPIOC_PDOR &= ~0x00080000;
}

#endif /* PE_LDD_VERSION */

uint16_t _bsp_set_clock_configuration
(
    /* [IN] runtime clock configuration */
    const BSP_CLOCK_CONFIGURATION clock_configuration
)
{
    KERNEL_DATA_STRUCT_PTR         kernel_data;
    uint32_t    system_clock;
    uint16_t    cpu_error = ERR_OK;

    cpu_error = Cpu_SetClockConfiguration((uint8_t)clock_configuration);
    if (cpu_error != ERR_OK)    {
        return cpu_error;
    }

    // Get system clock for active clock configuration
    system_clock = _cm_get_clock(clock_configuration, CM_CLOCK_SOURCE_CORE);

    // Re-initialize the system tick  timer
    systick_config(system_clock, BSP_ALARM_FREQUENCY);

    // Re-initialize the kernel system tick parameters
    _GET_KERNEL_DATA(kernel_data);
    kernel_data->TIMER_HW_REFERENCE = (system_clock / BSP_ALARM_FREQUENCY);   
    kernel_data->HW_TICKS_PER_TICK = kernel_data->TIMER_HW_REFERENCE;
    
    return ERR_OK;
}


BSP_CLOCK_CONFIGURATION _bsp_get_clock_configuration
(
    void
)
{
    return (BSP_CLOCK_CONFIGURATION)Cpu_GetClockConfiguration();
}


uint32_t _bsp_get_clock
(
    const BSP_CLOCK_CONFIGURATION   clock_configuration,
    const CM_CLOCK_SOURCE           clock_source
)
{
    if (    (clock_configuration < CPU_CLOCK_CONFIG_NUMBER)
         && (clock_source        < sizeof(CpuClockConfigurations)/sizeof(uint32_t))
        )
    {
        return *(((uint32_t *)&(CpuClockConfigurations[clock_configuration])) + clock_source);
    }
    else
    {
        return 0;
    }
}


uint16_t _bsp_osc_autotrim
(
    void
)
{
    uint16_t        CPU_Error = ERR_OK;
    uint8_t         MCG_Mode;
    /*
     * Its assumed that before auto trimming process
     * the MCG is switched to a clock configuration
     * which derives its bus clock from external reference clock
     * and (<MCG mode> is set to one of the following modes
     * FEE, FBE, BLPE, PEE, PBE) and if value of <Bus clock>
     * is in the range <8; 16>MHz.
     */

    /* Auto trim Slow internal reference clock */
    CPU_Error = Cpu_MCGAutoTrim(0);
    if (CPU_Error != ERR_OK) return CPU_Error;

    /* Auto trim Fast internal reference clock */
    CPU_Error = Cpu_MCGAutoTrim(1);
    if (CPU_Error != ERR_OK) return CPU_Error;

    return ERR_OK;

}

